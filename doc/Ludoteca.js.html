<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Ludoteca.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Ludoteca.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file Biblioteca de classes que representam os tipos mais comuns de &lt;em>gráficos&lt;/em> a desenhar num &lt;code>canvas&lt;/code> e também o próprio &lt;code>canvas&lt;/code>, bem como os elementos &lt;code>audio&lt;/code> e &lt;code>video&lt;/code>. O propósito desta biblioteca é facilitar o desenvolvimento de jogos e outras aplicações multimédia num contexto académico, gerando-se algum nível de abstracção relativamente a pormenores de implementação no código. Abordam-se apenas os tipos mais frequentes de gráficos e de elementos acessórios, evitando, quando possível, complexidade desnecessária.
 * @version 0.9.5
 * @author Ricardo Rodrigues
 * @date 2025-05-19
 * @copyright Ricardo Rodrigues (2021, 2022, 2023, 2024, 2025)
 */

//

/**
 * @class
 * @abstract
 * @classdesc A classe &lt;code>Grafico&lt;/code> é, para todos os efeitos, uma classe &lt;em>abstracta&lt;/em>, um esqueleto, servindo apenas de base (i.e., superclasse) para as subclasses de &lt;code>Grafico&lt;/code>.
 * @property {number} x Abscissa para posicionar o &lt;em>gráfico&lt;/em> no &lt;code>canvas&lt;/code>.
 * @property {number} y Ordenada para posicionar o &lt;em>gráfico&lt;/em> no &lt;code>canvas&lt;/code>.
 * @property {number} deltaX=0 Variação horizontal da posição do &lt;em>gráfico&lt;/em>, após cada iteração de desenho.
 * @property {number} deltaY=0 Variação vertical da posição do &lt;em>gráfico&lt;/em>, após cada iteração de desenho.
 * @property {number} distX=0 Distância horizontal do &lt;em>gráfico&lt;/em> até um dado ponto.
 * @property {number} distY=0 Distância vertical do &lt;em>gráfico&lt;/em> até um dado ponto.
 * @property {number} gravidade=0 Força que, quando usada em conjunto com um &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação vertical do &lt;em>gráfico&lt;/em>, actuando como a &lt;em>gravidade&lt;/em>.
 * @property {number} velocidade=0 Velocidade que, quando usada em conjunto com um &lt;em>ângulo (de rotação)&lt;/em>, pode ser utilizada para definir a variação horizontal e vertical do &lt;em>gráfico&lt;/em>.
 * @property {number} atrito=0.0 Força que reduz o movimento (sejam os &lt;em>deltas&lt;/em> ou a &lt;em>velocidade&lt;/em>) do &lt;em>gráfico&lt;/em>. O valor deve estar compreendido entre &lt;code>0&lt;/code> (sem atrito) e &lt;code>1&lt;/code> (movimento totalmente travado). Se o valor indicado estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code>, se inferior, ou para &lt;code>1.0&lt;/code>, se superior.
 * @property {number} anguloRotacao=0 Ângulo de rotação do &lt;em>gráfico&lt;/em> quando desenhado no &lt;code>canvas&lt;/code>, usado também em conjunto com a &lt;em>velocidade&lt;/em>, compreendido entre &lt;code>0&lt;/code> e &lt;code>360&lt;/code> &amp;mdash; independentemente do valor atribuído, é sempre usado o &lt;em>resto&lt;/em> da sua divisão por &lt;code>360&lt;/code>. A rotação é feita tendo como referência o centro do &lt;em>gráfico&lt;/em>.
 * @property {number} deltaRotacao=0 Variação do ângulo de rotação do &lt;em>gráfico&lt;/em>, após cada iteração de desenho.
 * @property {number} anguloGravidade=0 Ângulo cujo co-seno afecta a aplicação do sentido da &lt;em>gravidade&lt;/em> ao &lt;em>gráfico&lt;/em>, compreendido entre &lt;code>0&lt;/code> e &lt;code>180&lt;/code>. Se o valor indicado estiver fora deste intervalo, será corrigido para &lt;code>0&lt;/code>, se inferior, ou para &lt;code>360&lt;/code>, se superior.
 * @property {number} deltaGravidade=0 Variação do ângulo aplicado à &lt;em>gravidade&lt;/em>, após cada iteração de desenho.
 * @property {number} opacidade=1.0 Valor da opacidade do &lt;em>gráfico&lt;/em> &amp;mdash; pode variar entre &lt;code>0.0&lt;/code> (completamente transparente) e &lt;code>1.0&lt;/code> (completamente opaco). Se o valor atribuído estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code>, se inferior, ou para &lt;code>1.0&lt;/code>, se superior.
 * @property {boolean} activo=true Indicação de que o &lt;em>gráfico&lt;/em> deve testar colisões, quando chamado o método &lt;code>colide()&lt;/code>. Será útil quando os &lt;em>gráficos&lt;/em> são processados em bloco, por exemplo, num &lt;em>array&lt;/em>, e nem todos devem ser testados para colisões, ou mesmo para quando há momentos em que o &lt;em>gráfico&lt;/em> deve reagir a colisões e noutros não.
 * @property {boolean} visivel=true Indicação de que o &lt;em>gráfico&lt;/em> deve ser desenhado no &lt;code>canvas&lt;/code>, quando chamado o método &lt;code>desenha()&lt;/code>.
 * @property {boolean} actualiza=true Indicação de que o &lt;em>gráfico&lt;/em> deve ter o seu posicionamento actualizado após o seu &lt;em>desenho&lt;/em> na &lt;em>tela&lt;/em>.
 */
class Grafico {
  #anguloGravidade;
  #deltaGravidade;
  #anguloRotacao;
  #deltaRotacao;
  #totalDeltaX;
  #totalDeltaY;
  #velocidade;
  #gravidade;
  #opacidade;
  #actualiza;
  #capturado;
  #contador;
  #visivel;
  #atrito;
  #activo;
  #deltaX;
  #deltaY;
  #distX;
  #distY;
  #x;
  #y;

  /**
   * Construtor da classe &lt;code>Grafico&lt;/code> &amp;mdash; &lt;em>este construtor não pode ser usado directamente; caso tal aconteça, é gerada uma excepção (&lt;code>TypeError&lt;/code>)&lt;/em>.
   * @param {number} x Abscissa para posicionar o &lt;em>gráfico&lt;/em> no &lt;code>canvas&lt;/code>.
   * @param {number} y Ordenada para posicionar o &lt;em>gráfico&lt;/em> no &lt;code>canvas&lt;/code>.
   * @throws {Error} Se a classe for instanciada directamente &amp;mdash; não permitido.
   * @throws {TypeError} Se &lt;code>x&lt;/code> ou &lt;code>y&lt;/code> não forem números finitos.
   */
  constructor(x, y) {
    if (this.constructor.name === 'Grafico') {
      throw new Error('A classe abstracta "Grafico" não pode ser instanciada directamente, devendo ser implementada através de subclasses (que poderão então ser instanciadas).');
    }
    if (typeof x !== 'number' || !Number.isFinite(x)) {
      throw new TypeError('O parâmetro "x" deve ser um número finito.');
    }
    if (typeof y !== 'number' || !Number.isFinite(y)) {
      throw new TypeError('O parâmetro "y" deve ser um número finito.');
    }
    this.#x = x;
    this.#y = y;
    this.#deltaX = 0;
    this.#deltaY = 0;
    this.#distX = 0;
    this.#distY = 0;
    this.#gravidade = 0;
    this.#velocidade = 0;
    this.#atrito = 1.0;
    this.#totalDeltaX = 0;
    this.#totalDeltaY = 0;
    this.#anguloRotacao = 0;
    this.#deltaRotacao = 0;
    this.#anguloGravidade = 0;
    this.#deltaGravidade = 0;
    this.#activo = true;
    this.#visivel = true;
    this.#actualiza = true;
    this.#capturado = false;
    this.#opacidade = 1.0;
    this.#contador = 0;
  }

  set x(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "x" deve ser um número finito.');
    }
    this.#x = valor;
  }

  get x() {
    return this.#x;
  }

  set y(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "y" deve ser um número finito.');
    }
    this.#y = valor;
  }

  get y() {
    return this.#y;
  }

  set deltaX(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "deltaX" deve ser um número finito.');
    }
    this.#deltaX = valor;
  }

  get deltaX() {
    return this.#deltaX;
  }

  set deltaY(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "deltaX" deve ser um número finito.');
    }
    this.#deltaY = valor;
  }

  get deltaY() {
    return this.#deltaY;
  }

  set distX(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "distX" deve ser um número finito.');
    }
    this.#distX = valor;
  }

  get distX() {
    return this.#distX;
  }

  set distY(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "distY" deve ser um número finito.');
    }
    this.#distY = valor;
  }

  get distY() {
    return this.#distY;
  }

  set activo(valor) {
    if (typeof valor !== 'boolean') {
      throw new TypeError('O valor de "activo" deve ser booleano ("true" ou "false").');
    }
    this.#activo = valor;
  }

  get activo() {
    return this.#activo;
  }

  set visivel(valor) {
    if (typeof valor !== 'boolean') {
      throw new TypeError('O valor de "visivel" deve ser booleano ("true" ou "false").');
    }
    this.#visivel = valor;
  }

  get visivel() {
    return this.#visivel;
  }

  set actualiza(valor) {
    if (typeof valor !== 'boolean') {
      throw new TypeError('O valor de "actualiza" deve ser booleano ("true" ou "false").');
    }
    this.#actualiza = valor;
  }

  get actualiza() {
    return this.#actualiza;
  }

  set deltaGravidade(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "deltaGravidade" deve ser um número finito.');
    }
    this.#deltaGravidade = valor;
  }

  get deltaGravidade() {
    return this.#deltaGravidade;
  }

  set deltaRotacao(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "deltaRotacao" deve ser um número finito.');
    }
    this.#deltaRotacao = valor;
  }

  get deltaRotacao() {
    return this.#deltaRotacao;
  }

  set gravidade(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "gravidade" deve ser um número finito.');
    }
    if (valor &lt; 0) {
      throw new RangeError('O valor de "gravidade" não pode ser um número negativo.');
    }
    this.#gravidade = valor;
  }

  get gravidade() {
    return this.#gravidade;
  }

  set anguloGravidade(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "anguloGravidade" deve ser um número finito.');
    }
    this.#anguloGravidade = Math.min(180, Math.max(0, valor));
  }

  get anguloGravidade() {
    return this.#anguloGravidade;
  }

  set anguloRotacao(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "anguloRotacao" deve ser um número finito.');
    }
    this.#anguloRotacao = valor % 360;
  }

  get anguloRotacao() {
    return this.#anguloRotacao;
  }

  set velocidade(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "velocidade" deve ser um número finito.');
    }
    this.#velocidade = valor;
  }

  get velocidade() {
    return this.#velocidade;
  }

  set opacidade(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "opacidade" deve ser um número finito, idealmente entre 0.0 e 1.0.');
    }
    this.#opacidade = Math.min(1, Math.max(0, valor));
  }

  get opacidade() {
    return this.#opacidade;
  }

  set atrito(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "atrito" deve ser um número finito, idealmente entre 0.0 e 1.0.');
    }
    this.#atrito = 1.0 - Math.min(1, Math.max(0, valor));
  }

  get atrito() {
    return this.#atrito;
  }

  /**
   * Largura do &lt;em>gráfico&lt;/em>. Este método deve ser obrigatoriamente implementado em subclasses concretas.
   * @abstract
   * @readonly
   * @type {number}
   * @throws {Error} Método não implementado na subclasse.
   */
  get largura() {
    throw new Error('O método &lt;em>getter&lt;/em> "largura()" tem de ser implementado nas subclasses de "Grafico".');
  }

  /**
   * Altura do &lt;em>gráfico&lt;/em>. Este método deve ser obrigatoriamente implementado em subclasses concretas.
   * @abstract
   * @readonly
   * @type {number}
   * @throws {Error} Método não implementado na subclasse.
   */
  get altura() {
    throw new Error('O método &lt;em>getter&lt;/em> "altura()" tem de ser implementado nas subclasses de "Grafico".');
  }

  /**
   * Centróide do &lt;em>gráfico&lt;/em>, considerando a sua largura e a sua altura. Por omissão, corresponde ao centro do menor &lt;em>rectângulo imaginário&lt;/em> que envolva o &lt;em>gráfico&lt;/em>.
   * @readonly
   * @returns {{x: number, y: number}} Objecto representando o centróide, com propriedades &lt;code>x&lt;/code> e &lt;code>y&lt;/code>.
   */
  get centroide() {
    let centroideX = this.largura * 0.5;
    let centroideY = this.altura * 0.5;
    return { x: centroideX, y: centroideY };
  }

  /**
   * Conjunto de pontos que delimitam o &lt;em>gráfico&lt;/em>, definindo o seu &lt;em>invólucro&lt;/em>. Os pontos correspondem aos vértices do menor &lt;em>rectângulo imaginário&lt;/em> que envolva o &lt;em>gráfico&lt;/em>, considerando a rotação actual. Cada ponto é um objecto com as propriedades &lt;code>x&lt;/code> e &lt;code>y&lt;/code>.
   * @type {Array&lt;{x: number, y: number}>}
   * @readonly
   */
  get involucro() {
    let involucro = new Array();
    let verticesCartesianos = [{ x: 0, y: 0 }, { x: this.largura, y: 0 }, { x: this.largura, y: this.altura }, { x: 0, y: this.altura }];
    // para evitar processamento desnecessário, só se faz a criação do involucro com base na conversão das coordenadas cartesianas dos vertices em coordenadas polares e destas novamente em coordenadas cartesianas quando o ângulo é diferente de zero (0), já que, quando o ângulo tem esse valor, o resultado é idêntico a quando não se faz qualquer conversão
    if (this.anguloRotacao !== 0) {
      let verticesPolares = new Array(verticesCartesianos.length);
      for (let i = 0; i &lt; verticesPolares.length; i++) {
        verticesPolares[i] = Grafico.calculaCoordenadasPolares(verticesCartesianos[i].x - this.centroide.x, verticesCartesianos[i].y - this.centroide.y);
      }
      involucro = new Array(verticesPolares.length);
      for (let i = 0; i &lt; involucro.length; i++) {
        involucro[i] = { x: Grafico.calculaCoordenadasCartesianas(verticesPolares[i].distancia, verticesPolares[i].angulo + this.anguloRotacao).x + this.centroide.x + this.#x, y: Grafico.calculaCoordenadasCartesianas(verticesPolares[i].distancia, verticesPolares[i].angulo + this.anguloRotacao).y + this.centroide.y + this.#y };
      }
    }
    else {
      involucro = new Array(verticesCartesianos.length);
      for (let i = 0; i &lt; involucro.length; i++) {
        involucro[i] = { x: verticesCartesianos[i].x + this.#x, y: verticesCartesianos[i].y + this.#y };
      }
    }
    return involucro;
  }

  /**
   * Largura do menor &lt;em>rectângulo imaginário&lt;/em> que envolva o &lt;em>invólucro&lt;/em> deste &lt;em>gráfico&lt;/em>, sendo definida pela distância entre o &lt;em>x&lt;/em> do ponto mais à esquerda e o &lt;em>x&lt;/em> do ponto mais à direita do &lt;em>invólucro&lt;/em>.
   * @type {number}
   * @readonly
   */
  get largurainvolucro() {
    if (this.involucro.length === 0) {
      return 0;
    }
    else {
      let minX = Number.POSITIVE_INFINITY;
      let maxX = Number.NEGATIVE_INFINITY;
      for (let ponto of this.involucro) {
        minX = Math.min(minX, ponto.x);
        maxX = Math.max(maxX, ponto.x);
      }
      return maxX - minX;
    }
  }

  /**
   * Altura do menor &lt;em>rectângulo imaginário&lt;/em> que envolva o &lt;em>invólucro&lt;/em> deste &lt;em>gráfico&lt;/em>, sendo definida pela distância entre o &lt;em>x&lt;/em> do ponto mais acima e o &lt;em>x&lt;/em> do ponto mais abaixo do &lt;em>invólucro&lt;/em>.
   * @type {number}
   * @readonly
   */
  get alturainvolucro() {
    if (this.involucro.length === 0) {
      return 0;
    }
    else {
      let minY = Number.POSITIVE_INFINITY;
      let maxY = Number.NEGATIVE_INFINITY;
      for (let ponto of involucro) {
        minY = Math.min(minY, ponto.y);
        maxY = Math.max(maxY, ponto.y);
      }
      return maxY - minY;
    }
  }

  /**
   * Indicação de que o &lt;em>gráfico&lt;/em> se encontra (ou não) &lt;em>preso&lt;/em> às coordenadas do rato, seguindo o seu movimento e adoptando as suas coordenadas, quando chamado o método &lt;code>desenha()&lt;/code>.
   * @type {boolean}
   * @readonly
   */
  get capturado() {
    return this.#capturado;
  }

  /**
   * Deslocamento total no eixo dos &lt;em>xx&lt;/em>, considerando o &lt;code>deltaX&lt;/code>, a &lt;code>velocidade&lt;/code>, o &lt;code>anguloRotacao&lt;/code> e o &lt;code>deltaTempo&lt;/code>.
   * @type {number}
   * @readonly
   */
  get totalDeltaX() {
    return this.#totalDeltaX;
  }

  /**
   * Deslocamento total no eixo dos &lt;em>yy&lt;/em>, considerando o &lt;code>deltaY&lt;/code>, a &lt;code>velocidade&lt;/code>, o &lt;code>anguloRotacao&lt;/code>, a &lt;code>gravidade&lt;/code>, o &lt;code>anguloGravidade&lt;/code> e o &lt;code>deltaTempo&lt;/code>.
   * @type {number}
   * @readonly
   */
  get totalDeltaY() {
    return this.#totalDeltaY;
  }

  /**
   * Verifica se existe uma colisão entre &lt;em>este gráfico&lt;/em> e &lt;em>outro&lt;/em>. Tal ocorre quando um dos pontos de um &lt;em>gráfico&lt;/em> se encontra contido na área de &lt;em>outro&lt;/em>. Para o efeito, são usados os pontos que definem o &lt;em>invólucro&lt;/em> de cada &lt;em>gráfico&lt;/em>. Também permite, caso se verifique a colisão, reposicionar &lt;em>este gráfico&lt;/em>, deixando-o encostado (ou próximo disso, consoante o valor do &lt;em>afastamento&lt;/em>) ao &lt;em>outro&lt;/em>, evitando a sobreposição de ambos. O &lt;em>reposicionamento&lt;/em> depende da posição imediatamente anterior &lt;em>deste gráfico&lt;/em> em relação ao &lt;em>outro&lt;/em>.
   * @param {Grafico} outro Outro &lt;em>gráfico&lt;/em> para verificar se existe alguma colisão entre &lt;em>esse&lt;/em> e &lt;em>este&lt;/em>.
   * @param {boolean} [reposiciona=true] Indicação de que este &lt;em>gráfico&lt;/em> deve ser reposicionado (ou não) quando colide com o &lt;em>outro&lt;/em>.
   * @param {number} [afastamento=0] Afastamento a aplicar entre os dois &lt;em>gráficos&lt;/em> no reposicionamento; idealmente, este deve ser compreendido entre zero (&lt;code>0&lt;/code>) e um valor inferior aos valores de quaisquer deslocamentos horizontais e verticais.
   * @param {number} [omissoes=0] Número de &lt;em>omissoes&lt;/em> em chamadas consecutivas &amp;mdash; pode ser útil definir um número de &lt;em>omissoes&lt;/em> superior a zero (&lt;code>0&lt;/code>) em situações com verificações de colisões entre muitos &lt;em>gráficos&lt;/em> em simultâneo, de forma a diminuir a exigência computacional.
   * @returns {boolean} Se houver colisão, &lt;code>true&lt;/code>, ou, no caso de se aplicar reposicionamento, &lt;code>1&lt;/code>, &lt;code>2&lt;/code>, &lt;code>3&lt;/code>, &lt;code>4&lt;/code> ou &lt;code>5&lt;/code>, correspondentes às posições &lt;em>cima&lt;/em>, &lt;em>baixo&lt;/em>, &lt;em>esquerda&lt;/em>, &lt;em>direita&lt;/em> ou &lt;em>indeterminada&lt;/em>, respectivamente &amp;mdash; valores também representados, respectivamente, pelas constantes &lt;code>Grafico.CIMA&lt;/code>, &lt;code>Grafico.BAIXO&lt;/code>, &lt;code>Grafico.ESQUERDA&lt;/code>, &lt;code>Grafico.DIREITA&lt;/code> e &lt;code>Grafico.INDETERMINADO&lt;/code>; senão, &lt;code>false&lt;/code>.
   * @throws {TypeError} Se o parâmetro &lt;code>outro&lt;/code> não for uma instância de uma subclasse de &lt;code>Grafico&lt;/code>.
   * @throws {TypeError} Se o parâmetro &lt;code>reposiciona&lt;/code> não for do tipo booleano.
   * @throws {TypeError} Se o parâmetro &lt;code>afastamento&lt;/code> não for um número finito e não negativo.
   * @throws {RangeError} Se o parâmetro &lt;code>afastamento&lt;/code> não for um número não negativo.
   * @throws {TypeError} Se o parâmetro &lt;code>omissoes&lt;/code> não for um número inteiro.
   * @throws {RangeError} Se o parâmetro &lt;code>omissoes&lt;/code> não for um número não negativo.
   */
  colide(outro, reposiciona = false, afastamento = 0, omissoes = 0) {
    if (!(outro instanceof Grafico)) {
      throw new TypeError('O parâmetro "outro" deve ser uma instância de uma subclasse de "Grafico".');
    }
    if (typeof reposiciona !== 'boolean') {
      throw new TypeError('O parâmetro "reposiciona" deve ser do tipo booleano.');
    }
    if (typeof afastamento !== 'number' || !Number.isFinite(afastamento)) {
      throw new TypeError('O parâmetro "afastamento" deve ser um número finito.');
    }
    if (afastamento &lt; 0) {
      throw new RangeError('O parâmetro "afastamento" não pode ser um número negativo.');
    }
    if (typeof omissoes !== 'number' || !Number.isInteger(omissoes)) {
      throw new TypeError('O parâmetro "omissoes" deve ser um número inteiro');
    }
    if (omissoes &lt; 0) {
      throw new RangeError('O parâmetro "omissoes" não pode ser um número negativo.');
    }
    this.#contador++;
    if (!reposiciona) {
      return (((this.#contador % (omissoes + 1)) === 0) &amp;&amp; this.#activo &amp;&amp; outro.activo &amp;&amp; (this.contemPontos(outro.involucro) || outro.contemPontos(this.involucro)));
    }
    else {
      if (((this.#contador % (omissoes + 1)) === 0) &amp;&amp; this.#activo &amp;&amp; outro.activo &amp;&amp; (this.contemPontos(outro.involucro) || outro.contemPontos(this.involucro))) {
        let sobreposicaoX = Math.min(this.#x + this.largura - outro.x, outro.x + outro.largura - this.#x);
        let sobreposicaoY = Math.min(this.#y + this.altura - outro.y, outro.y + outro.altura - this.#y);
        let posicao = Grafico.INDETERMINADA;
        if (sobreposicaoX &lt; sobreposicaoY) {        // colisão: horizontal
          if (this.#x &lt; outro.x) {
            this.#x -= sobreposicaoX + afastamento; // posição: esquerda
            posicao = Grafico.ESQUERDA;
          }
          else {
            this.#x += sobreposicaoX + afastamento; // posição: direita
            posicao = Grafico.DIREITA;
          }
        }
        else {                                      // colisão: vertical
          if (this.#y &lt; outro.y) {
            this.#y -= sobreposicaoY + afastamento; // posição: cima
            posicao = Grafico.CIMA;
          }
          else {
            this.#y += sobreposicaoY + afastamento; // posição: baixo
            posicao = Grafico.BAIXO;
          }
        }
        return posicao;
      }
      else {
        return false;
      }
    }
  }

  /**
   * Verifica se algum dos pontos de um &lt;em>array&lt;/em> está contido na área deste &lt;em>gráfico&lt;/em>, chamando o método &lt;code>contemPonto()&lt;/code> para cada elemento do &lt;em>array&lt;/em>.
   * @param {Array&lt;{x: number, y: number}>} pontos Conjunto de pontos a verificar (coordenadas &lt;code>x&lt;/code> e &lt;code>y&lt;/code> numéricas).
   * @returns {boolean} Se algum um dos pontos constantes no &lt;em>array&lt;/em> estiver contido neste &lt;em>gráfico&lt;/em>, &lt;code>true&lt;/code>; caso contrário, &lt;code>false&lt;/code>.
   * @throws {TypeError} Se o parâmetro &lt;code>pontos&lt;/code> não for um &lt;em>array&lt;/em>.
   * @throws {TypeError} Se algum elemento do &lt;em>array&lt;/em> não for um objecto com propriedades numéricas &lt;code>x&lt;/code> e &lt;code>y&lt;/code>.
   */
  contemPontos(pontos) {
    if (!Array.isArray(pontos)) {
      throw new TypeError('O parâmetro "pontos" deve ser um "array" de objectos com as propriedades numéricas "x" e "y".');
    }
    for (let ponto of pontos) {
      if (typeof ponto !== 'object' || typeof ponto.x !== 'number' || typeof ponto.y !== 'number') {
        throw new TypeError('Cada um dos elementos do "array" pontos deve ser um objecto com propriedades numéricas "x" e "y".');
      }
      if (this.contemPonto(ponto.x, ponto.y)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Verifica se um dado &lt;em>ponto&lt;/em> está contido área do &lt;em>invólucro&lt;/em> rectangular que envolve este &lt;em>gráfico&lt;/em>. Tal acontece quando esse &lt;em>ponto&lt;/em> está compreendido entre &lt;em>x&lt;/em> e &lt;em>x mais a largura&lt;/em> e entre &lt;em>y&lt;/em> e &lt;em>y mais altura&lt;/em> desse &lt;em>invólucro&lt;/em>. O teste é realizado utilizando o algoritmo do número de intersecções, verificando a sua paridade &amp;mdash:  conhecido como &lt;em>ray casting&lt;/em>.
   * @param {number} x Abscissa do ponto a testar se está contido neste &lt;em>gráfico&lt;/em>.
   * @param {number} y Ordenada do ponto a testar se está contido neste &lt;em>gráfico&lt;/em>.
   * @returns {boolean} Se o ponto estiver contido neste &lt;em>gráfico&lt;/em>, &lt;code>true&lt;/code>; senão, &lt;code>false&lt;/code>.
   * @throws {TypeError} Se &lt;code>x&lt;/code> ou &lt;code>y&lt;/code> não forem números finitos.
   */
  contemPonto(x, y) {
    if (typeof x !== 'number' || !Number.isFinite(x)) {
      throw new TypeError('O parâmetro "x" deve ser um número finito.');
    }
    if (typeof y !== 'number' || !Number.isFinite(y)) {
      throw new TypeError('O parâmetro "y" deve ser um número finito.');
    }
    let interseccoes = 0;
    for (let i = 0, j = this.involucro.length - 1; i &lt; this.involucro.length; j = i++) {
      let xi = this.involucro[i].x, yi = this.involucro[i].y;
      let xj = this.involucro[j].x, yj = this.involucro[j].y;
      if (((yi > y) !== (yj > y)) &amp;&amp; (x &lt; (xj - xi) * (y - yi) / (yj - yi) + xi)) {
        interseccoes++;
      }
    }
    if (interseccoes % 2 === 0) {
      return false;
    }
    return true;
  }

  /**
   * Faz com que o &lt;em>gráfico&lt;/em> fique &lt;em>preso&lt;/em> às coordenadas do rato, seguindo o seu movimento e adoptando as suas coordenadas. O &lt;em>gráfico&lt;/em> passa a acompanhar o rato, ajustando a sua posição com base na diferença inicial entre as suas coordenadas e as do rato.
   * @param {Tela} tela Objecto que representa o elemento &lt;code>canvas&lt;/code>, do qual se vai obter as coordenados do rato, que o &lt;em>gráfico&lt;/em> irá seguir e adoptar (fazendo as necessárias compensações posicionais).
   * @throws {TypeError} Se o parâmetro &lt;code>tela&lt;/code> não for uma instância de &lt;code>Tela&lt;/code>.
   */
  captura(tela) {
    if (!(tela instanceof Tela)) {
      throw new TypeError('O parâmetro "tela" deve ser uma instância de "Tela".');
    }
    if (!this.#capturado) {
      this.#capturado = true;
      this.#distX = this.#x - tela.ratoX;
      this.#distY = this.#y - tela.ratoY;
    }
  }

  /**
   * Faz com que o &lt;em>gráfico&lt;/em> deixe de ficar &lt;em>preso&lt;/em> às coordenadas do rato. Após a chamada deste método, o &lt;em>gráfico&lt;/em> deixa de acompanhar o movimento do rato.
   */
  liberta() {
    if (this.#capturado) {
      this.#capturado = false;
      this.#distX = 0;
      this.#distY = 0;
    }
  }

  /**
   * Inverte o sentido da força da gravidade aplicada sobre o &lt;em>gráfico&lt;/em>, desde que esta seja diferente de zero, colocando o valor interno de &lt;code>anguloGravidade&lt;/code> em &lt;code>180&lt;/code> graus (cujo co-seno é usado). Se &lt;code>deltaGravidade&lt;/code> estiver definido e for um número negativo, a inversão será temporária, voltando-se posteriormente ao sentido inicialmente definido.
   */
  inverteGravidade() {
    this.#anguloGravidade = 180;
  }

  /**
   * Repõe o sentido inicial da força da gravidade aplicada sobre o &lt;em>gráfico&lt;/em>, contanto esta seja diferente de zero, colocando o valor interno de &lt;code>anguloGravidade&lt;/code> de volta a &lt;code>0&lt;/code> graus (cujo co-seno é usado).
   */
  repoeGravidade() {
    this.#anguloGravidade = 0;
  }

  /**
   * &lt;em>Este método abstracto deve ser terminado de implementar nas subclasses de &lt;code>Grafico&lt;/code>, respeitando as especificidades de cada &lt;em>gráfico&lt;/em> representado nelas. Contém já um conjunto de instruções transversais a qualquer subclasse, como a rotação, a opacidade ou a actualização das coordenadas após o desenho, sendo esperado que os métodos das subclasses especifiquem apenas as instruções para desenho do respectivo &lt;em>gráfico&lt;/em>, passando uma função com essas instruções como argumento deste método (para além da &lt;em>tela&lt;/em>). Para além disso, opcionalmente, também recebe como argumento um &lt;em>delta tempo&lt;/em>, de modo a garantir uma uniformização das animações e dos movimentos entre diferentes dispositivos. Se este argumento for usado, as &lt;em>variações&lt;/em> das coordenadas devem ser expressas em função de um segundo &amp;mdash; i.e., &lt;em>pixels&lt;/em> por segundo; caso contrário, assume-se que a &lt;em>variação&lt;/em> é definida em função de cada iteração &amp;mdash; i.e., &lt;em>pixels&lt;/em> por chamada ao método &lt;code>desenha()&lt;/code>.&lt;/em>.
   * @abstract
   * @param {Tela} tela Objecto que representa o elemento &lt;code>canvas&lt;/code> onde será desenhado o &lt;em>gráfico&lt;/em>
   * @param {function} desenhaGrafico Instruções que especificam e desenham o &lt;em>gráfico&lt;/em> no &lt;em>canvas&lt;/em>
   * @param {number} [deltaTempo=1] Variação temporal entre chamadas (para sincronização de animações); se não for fornecido, assume-se o valor &lt;code>1&lt;/code> &amp;mdash; isto é, que a actualização posicional decorrente do desenho está a ser feita em função do número de iterações e não do tempo.
   * @throws {TypeError} Se o parâmetro &lt;code>tela&lt;/code> não for uma instância de &lt;code>Tela&lt;/code>.
   * @throws {TypeError} Se o parâmetro &lt;code>desenhaGrafico&lt;/code> não for uma função.
   * @throws {TypeError} Se o parâmetro &lt;code>deltaTempo&lt;/code> não for um número finito.
   * @throws {RangeError} Se o parâmetro &lt;code>deltaTempo&lt;/code> for um número negativo.
   * @throws {Error} Se o método for chamado directamente na classe abstracta &lt;code>Grafico&lt;/code>.
   */
  desenha(tela, desenhaGrafico, deltaTempo = 1) {
    if (!tela instanceof Tela) {
      throw new TypeError('O parâmetro "tela" deve ser uma instância de "Tela".');
    }
    if (typeof desenhaGrafico !== 'function') {
      throw new TypeError('O parâmetro "desenhaGrafico" deve ser uma função.');
    }
    if (typeof deltaTempo !== 'number' || !Number.isFinite(deltaTempo)) {
      throw new TypeError('O parâmetro "deltaTempo" deve ser um número finito.');
    }
    if (deltaTempo &lt; 0) {
      throw new RangeError('O parâmetro "deltaTempo" não pode ser um número negativo.');
    }
    if (this.constructor === Grafico) {
      throw new Error('O método abstracto "desenha()" deve ser implementado nas subclasses de "Grafico".');
    }
    if (this.#visivel) {
      const contexto = tela.contexto;
      contexto.save();
      contexto.translate(Math.floor(this.#x + this.centroide.x), Math.floor(this.#y + this.centroide.y));
      contexto.rotate(this.#anguloRotacao * Math.PI / 180);
      contexto.globalAlpha = this.#opacidade;
      desenhaGrafico();
      contexto.restore();
    }
    if (this.#capturado) {
      this.#x = tela.ratoX + this.#distX;
      this.#y = tela.ratoY + this.#distY;
    }
    else if (this.#actualiza) {
      this.#totalDeltaX = (this.#deltaX + this.#velocidade * Math.cos(this.#anguloRotacao * Math.PI / 180)) * this.#atrito * deltaTempo;
      this.#totalDeltaY = ((this.#deltaY + this.#velocidade * Math.sin(this.#anguloRotacao * Math.PI / 180)) * this.#atrito + this.#gravidade * Math.cos(this.#anguloGravidade * Math.PI / 180)) * deltaTempo;
      this.#x += this.#totalDeltaX;
      this.#y += this.#totalDeltaY;
      this.anguloRotacao += this.#deltaRotacao * deltaTempo;
      this.anguloGravidade += this.#deltaGravidade * deltaTempo;
    }
  }

  /**
   * Constante que representa um &lt;em>reposicionamento&lt;/em> em &lt;em>cima&lt;/em> &amp;mdash; usada no método &lt;code>colide()&lt;/code>, com &lt;code>reposiciona=true&lt;/code>, da classe &lt;code>Grafico&lt;/code> e respectivas subclasses.
   * @constant
   * @type {number}
   * @default 1
   */
  static CIMA = 1;

  /**
   * Constante que representa um &lt;em>reposicionamento&lt;/em> em &lt;em>baixo&lt;/em> &amp;mdash; usada no método &lt;code>colide()&lt;/code>, com &lt;code>reposiciona=true&lt;/code>, da classe &lt;code>Grafico&lt;/code> e respectivas subclasses.
   * @constant
   * @type {number}
   * @default 2
   */
  static BAIXO = 2;

  /**
   * Constante que representa um &lt;em>reposicionamento&lt;/em> à &lt;em>esquerda&lt;/em> &amp;mdash; usada no método &lt;code>colide()&lt;/code>, com &lt;code>reposiciona=true&lt;/code>, da classe &lt;code>Grafico&lt;/code> e respectivas subclasses.
   * @constant
   * @type {number}
   * @default 3
   */
  static ESQUERDA = 3;

  /**
   * Constante que representa um &lt;em>reposicionamento&lt;/em> à &lt;em>direita&lt;/em> &amp;mdash; usada no método &lt;code>colide()&lt;/code>, com &lt;code>reposiciona=true&lt;/code>, da classe &lt;code>Grafico&lt;/code> e respectivas subclasses.
   * @constant
   * @type {number}
   * @default 4
   */
  static DIREITA = 4;

  /**
   * Constante que representa o caso em que há uma &lt;em>colisão&lt;/em>, mas, por algum caso extremo, não foi possível determinar a posição anterior do gráfico antes da colisão e realizar o devido &lt;em>reposicionamento&lt;/em>; usada no método &lt;code>colide()&lt;/code>, com &lt;code>reposiciona=true&lt;/code>, da classe &lt;code>Grafico&lt;/code> e respectivas subclasses.
   * @constant
   * @type {number}
   * @default 5
   */
  static INDETERMINADA = 5;

  /**
   * Calcula as coordenadas polares de um dado ponto cartesiano, devolvendo o &lt;em>ângulo polar&lt;/em> (em graus, no intervalo [0, 360[) e a &lt;em>distância radial&lt;/em>.
   * @param {number} x Abscissa do ponto cartesiano.
   * @param {number} y Ordenada do ponto cartesiano.
   * @returns {{distancia: number, angulo: number|undefined}} Objecto com as coordenadas polares do ponto:
   * &lt;ul>
   *   &lt;li>&lt;code>distancia&lt;/code> - distância radial ao ponto de origem&lt;/li>
   *   &lt;li>&lt;code>angulo&lt;/code> - ângulo polar em graus (no intervalo [0, 360[), ou &lt;code>undefined&lt;/code> se a distância for zero&lt;/li>
   * &lt;/ul>
   * @throws {TypeError} Se &lt;code>x&lt;/code> ou &lt;code>y&lt;/code> não forem números finitos.
   */
  static calculaCoordenadasPolares(x, y) {
    if (typeof x !== 'number' || !Number.isFinite(x)) {
      throw new TypeError('O parâmetro "x" deve ser um número finito.');
    }
    if (typeof y !== 'number' || !Number.isFinite(y)) {
      throw new TypeError('O parâmetro "y" deve ser um número finito.');
    }
    let distancia = Math.hypot(x, y);
    let angulo = undefined;
    if (distancia !== 0) {
      angulo = Math.atan2(y, x) * 180 / Math.PI;
      if (angulo &lt; 0) {
        angulo += 360;
      }
    }
    return { distancia, angulo };
  }

  /**
   * Cálcula as coordenadas cartesianas de um dado ponto polar, devolvendo o &lt;em>x&lt;/em> e o &lt;em>y&lt;/em>.
   * @param {number} distancia Distância radial do ponto.
   * @param {number} angulo Ângulo polar (em graus) do ponto.
   * @returns {{x: number, y: number}} Coordenadas cartesianas do ponto: &lt;em>x&lt;/em> e &lt;em>y&lt;/em>.
   * @throws {TypeError} Se &lt;code>distancia&lt;/code> ou &lt;code>angulo&lt;/code> não forem números finitos.
   */
  static calculaCoordenadasCartesianas(distancia, angulo = 0) {
    if (typeof distancia !== 'number' || !Number.isFinite(distancia)) {
      throw new TypeError('O parâmetro "distancia" deve ser um número finito.');
    }
    if (typeof angulo !== 'number' || !Number.isFinite(angulo)) {
      throw new TypeError('O parâmetro "angulo" deve ser um número finito.');
    }
    let x = distancia * Math.cos(angulo * Math.PI / 180);
    let y = distancia * Math.sin(angulo * Math.PI / 180);
    return { x, y };
  }
}

//

/**
 * @class
 * @extends Grafico
 * @classdesc A classe &lt;code>Circulo&lt;/code> é uma subclasse de &lt;code>Grafico&lt;/code>, servindo para representar &lt;em>círculos&lt;/em>. Num nível básico, um &lt;em>círculo&lt;/em> é definido por um &lt;em>ponto&lt;/em> central e por um &lt;em>raio&lt;/em>. Contudo, para que exista uniformidade no posicionamento das formas representadas pelas várias subclasses de &lt;code>Grafico&lt;/code>, os círculos são também posicionados usando o canto superior esquerdo (de um &lt;em>quadrado imaginário&lt;/em> que o contenha), em vez do seu centro &amp;mdash; assim, o &lt;em>raio&lt;/em> é somado ao &lt;em>x&lt;/em> e ao &lt;em>y&lt;/em> para fazer as devidas compensações de posicionamento, determinando o &lt;em>centro&lt;/em>.
 * @property {number} x Abscissa para posicionar o &lt;em>círculo&lt;/em> no &lt;code>canvas&lt;/code>.
 * @property {number} y Ordenada para posicionar o &lt;em>círculo&lt;/em> no &lt;code>canvas&lt;/code>.
 * @property {number} raio Raio do &lt;em>círculo&lt;/em>.
 * @property {string} preenchimento Cor ou padrão do preenchimento &lt;em>círculo&lt;/em>.
 * @property {string} contorno Cor ou padrão do contorno do &lt;em>círculo&lt;/em>.
 * @property {number} espessura Espessura do contorno do &lt;em>círculo&lt;/em> &amp;mdash. Se a &lt;em>espessura&lt;/em> tiver um valor igual a zero (&lt;code>0&lt;/code>), o contorno não é desenhado.
 * @property {number} deltaX=0 Variação horizontal da posição do &lt;em>círculo&lt;/em>, após cada iteração de desenho.
 * @property {number} deltaY=0 Variação vertical da posição do &lt;em>círculo&lt;/em>, após cada iteração de desenho.
 * @property {number} distX=0 Distância horizontal do &lt;em>círculo&lt;/em> até um dado ponto.
 * @property {number} distY=0 Distância vertical do &lt;em>círculo&lt;/em> até um dado ponto.
 * @property {number} gravidade=0 Força que, quando usada em conjunto com um &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação vertical do &lt;em>círculo&lt;/em>, actuando como a &lt;em>gravidade&lt;/em>.
 * @property {number} velocidade=0 Velocidade que, quando usada em conjunto com um &lt;em>ângulo (de rotação)&lt;/em>, pode ser utilizada para definir a variação horizontal e vertical do &lt;em>círculo&lt;/em>.
 * @property {number} atrito=0.0 Força que reduz o movimento (sejam os &lt;em>deltas&lt;/em> ou a &lt;em>velocidade&lt;/em>) do &lt;em>círculo&lt;/em>. O valor deve estar compreendido entre &lt;code>0&lt;/code> (sem atrito) e &lt;code>1&lt;/code> (movimento totalmente travado). Se o valor indicado estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code>, se inferior, ou para &lt;code>1.0&lt;/code>, se superior.
 * @property {number} anguloRotacao=0 Ângulo de rotação do &lt;em>círculo&lt;/em> quando desenhado no &lt;code>canvas&lt;/code>, usado também em conjunto com a &lt;em>velocidade&lt;/em>, compreendido entre &lt;code>0&lt;/code> e &lt;code>360&lt;/code> &amp;mdash; independentemente do valor atribuído, é sempre usado o &lt;em>resto&lt;/em> da sua divisão por &lt;code>360&lt;/code>. A rotação é feita tendo como referência o centro do &lt;em>círculo&lt;/em>.
 * @property {number} deltaRotacao=0 Variação do ângulo de rotação do &lt;em>círculo&lt;/em>, após cada iteração de desenho.
 * @property {number} anguloGravidade=0 Ângulo cujo co-seno afecta a aplicação do sentido da &lt;em>gravidade&lt;/em> ao &lt;em>círculo&lt;/em>, compreendido entre &lt;code>0&lt;/code> e &lt;code>180&lt;/code>. Se o valor indicado estiver fora deste intervalo, será corrigido para &lt;code>0&lt;/code>, se inferior, ou para &lt;code>360&lt;/code>, se superior.
 * @property {number} deltaGravidade=0 Variação do ângulo aplicado à &lt;em>gravidade&lt;/em>, após cada iteração de desenho.
 * @property {number} opacidade=1.0 Valor da opacidade do &lt;em>círculo&lt;/em> &amp;mdash; pode variar entre &lt;code>0.0&lt;/code> (completamente transparente) e &lt;code>1.0&lt;/code> (completamente opaco). Se o valor atribuído estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code>, se inferior, ou para &lt;code>1.0&lt;/code>, se superior.
 * @property {boolean} activo=true Indicação de que o &lt;em>círculo&lt;/em> deve testar colisões, quando chamado o método &lt;code>colide()&lt;/code>. Será útil quando os &lt;em>círculo&lt;/em> são processados em bloco, por exemplo, num &lt;em>array&lt;/em>, e nem todos devem ser testados para colisões, ou mesmo para quando há momentos em que o &lt;em>círculo&lt;/em> deve reagir a colisões e noutros não.
 * @property {boolean} visivel=true Indicação de que o &lt;em>círculo&lt;/em> deve ser desenhado no &lt;code>canvas&lt;/code>, quando chamado o método &lt;code>desenha()&lt;/code>.
 * @property {boolean} actualiza=true Indicação de que o &lt;em>círculo&lt;/em> deve ter o seu posicionamento actualizado após o seu &lt;em>desenho&lt;/em> na &lt;em>tela&lt;/em>.
*/
class Circulo extends Grafico {
  #preenchimento;
  #espessura;
  #resolucao;
  #contorno;
  #raio;

  /**
   * Construtor para criação de novos objectos do tipo &lt;code>Círculo&lt;/code>.
   * @param {number} x Abscissa para posicionar o &lt;em>círculo&lt;/em> no &lt;code>canvas&lt;/code>.
   * @param {number} y Ordenada para posicionar o &lt;em>círculo&lt;/em> no &lt;code>canvas&lt;/code>.
   * @param {number} raio Raio do &lt;em>círculo&lt;/em>.
   * @param {string|CanvasPattern} [preenchimento='black'] Cor ou padrão do preenchimento do &lt;em>círculo&lt;/em>.
   * @param {string|CanvasPattern} [contorno='black'] Cor ou padrão do contorno do &lt;em>círculo&lt;/em>.
   * @param {number} [espessura=0] Espessura do contorno do &lt;em>círculo&lt;/em>.
   * @throws {TypeError} Se &lt;code>x&lt;/code> ou &lt;code>y&lt;/code> não forem números finitos.
   * @throws {TypeError} Se &lt;code>raio&lt;/code> não for um número finito.
   * @throws {RangeError} Se &lt;code>raio&lt;/code> não for um número positivo.
   * @throws {TypeError} Se &lt;code>preenchimento&lt;/code> ou &lt;code>contorno&lt;/code> não forem cadeias de caracteres.
   * @throws {TypeError} Se &lt;code>espessura&lt;/code> não for um número finito.
   * @throws {RangeError} Se &lt;code>espessura&lt;/code> for um número negativo.
   */
  constructor(x, y, raio, preenchimento = 'black', contorno = 'black', espessura = 0) {
    if (typeof x !== 'number' || !Number.isFinite(x)) {
      throw new TypeError('O parâmetro "x" deve ser um número finito.');
    }
    if (typeof y !== 'number' || !Number.isFinite(y)) {
      throw new TypeError('O parâmetro "y" deve ser um número finito.');
    }
    if (typeof raio !== 'number' || !Number.isFinite(raio)) {
      throw new TypeError('O parâmetro "raio" deve ser um número finito.');
    }
    if (raio &lt;= 0) {
      throw new RangeError('O parâmetro "raio" deve ser um número positivo.');
    }
    if (typeof preenchimento !== 'string' &amp;&amp; !(preenchimento instanceof CanvasPattern)) {
      throw new TypeError('O parâmetro "preenchimento" deve ser uma "string" ou um objecto do tipo "CanvasPattern".');
    }
    if (typeof contorno !== 'string' &amp;&amp; !(contorno instanceof CanvasPattern)) {
      throw new TypeError('O parâmetro "contorno" deve ser uma "string" ou um objecto do tipo "CanvasPattern".');
    }
    if (typeof espessura !== 'number' || !Number.isFinite(espessura)) {
      throw new TypeError('O parâmetro "espessura" deve ser um número finito.');
    }
    if (espessura &lt; 0) {
      throw new RangeError('O parâmetro "espessura" não pode ser um número negativo.');
    }
    super(x, y);
    this.#raio = raio;
    this.#preenchimento = preenchimento;
    this.#contorno = contorno;
    this.#espessura = espessura;
    this.#resolucao = 36;
  }

  get raio() {
    return this.#raio;
  }

  set raio(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "raio" deve ser um número finito.');
    }
    if (valor &lt;= 0) {
      throw new TypeError('O valor de "raio" deve ser um número positivo.');
    }
    this.#raio = valor;
  }

  set preenchimento(valor) {
    if (typeof valor !== 'string' &amp;&amp; typeof valor !== 'CanvasPattern') {
      throw new TypeError('O valor de "preenchimento" deve ser uma "string" ou um objecto do tipo "CanvasPattern".');
    }
    this.#preenchimento = valor;
  }

  get preenchimento() {
    return this.#preenchimento;
  }

  set espessura(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "espessura" deve ser um número finito.');
    }
    if (valor &lt; 0) {
      throw new RangeError('O valor de "espessura" não pode ser um número negativo.');
    }
    this.#espessura = valor;
  }

  get espessura() {
    return this.#espessura;
  }

  set contorno(valor) {
    if (typeof valor !== 'string' &amp;&amp; typeof valor !== 'CanvasPattern') {
      throw new TypeError('O valor de "preenchimento" deve ser uma "string" ou um objecto do tipo "CanvasPattern".');
    }
    this.#contorno = valor;
  }

  get contorno() {
    return this.#contorno;
  }

  /**
   * Conjunto de pontos que delimitam o &lt;em>círculo&lt;/em>, definindo um &lt;em>invólucro&lt;/em>.
   * @type {Array&lt;{x: number, y: number}>}
   * @readonly
   */
  get involucro() {
    let involucro = new Array(this.#resolucao);
    for (let i = 0; i &lt; involucro.length; i++) {
      involucro[i] = { x: this.#raio + this.#raio * Math.cos(2 * Math.PI * i / involucro.length + Math.PI) + this.x, y: this.#raio + this.#raio * Math.sin(2 * Math.PI * i / involucro.length + Math.PI) + this.y };
    }
    return involucro;
  }

  /**
   * Largura do menor &lt;em>quadrado imaginário&lt;/em> que envolva este &lt;em>círculo&lt;/em> &amp;mdash; na prática, corresponde ao diâmetro.
   * @type {number}
   * @readonly
   */
  get largura() {
    return this.#raio * 2;
  }

  /**
   * Altura do menor &lt;em>quadrado imaginário&lt;/em> que envolva este &lt;em>círculo&lt;/em> &amp;mdash; na prática, corresponde ao diâmetro.
   * @type {number}
   * @readonly
   */
  get altura() {
    return this.#raio * 2;
  }

  /**
   * Verifica se um dado &lt;em>ponto&lt;/em> está contido na área deste &lt;em>círculo&lt;/em>. Tal acontece quando a distância desse &lt;em>ponto&lt;/em> ao centro do &lt;em>círculo&lt;/em> é inferior ao &lt;em>raio&lt;/em> do &lt;em>círculo&lt;/em>.
   * @param {number} x Abscissa do ponto a testar se está contido neste &lt;em>círculo&lt;/em>.
   * @param {number} y Ordenada do ponto a testar se está contido neste &lt;em>círculo&lt;/em>.
   * @returns {boolean} Se o ponto estiver contido neste &lt;em>círculo&lt;/em>, &lt;code>true&lt;/code>; senão, &lt;code>false&lt;/code>.
   * @throws {TypeError} Se &lt;code>x&lt;/code> ou &lt;code>y&lt;/code> não forem números finitos.
   */
  contemPonto(x, y) {
    if (typeof x !== 'number' || !Number.isFinite(x)) {
      throw new TypeError('O parâmetro "x" deve ser um número finito.');
    }
    if (typeof y !== 'number' || !Number.isFinite(y)) {
      throw new TypeError('O parâmetro "y" deve ser um número finito.');
    }
    return (Math.hypot((this.x + this.#raio) - x, (this.y + this.#raio) - y) &lt; this.#raio);
  }

  /**
   * Desenha um &lt;em>círculo&lt;/em> no &lt;code>canvas&lt;/code>, usando como referência de posicionamento o &lt;em>ponto&lt;/em> correspondente ao canto superior esquerdo do menor &lt;em>quadrado imaginário&lt;/em> que envolva o &lt;em>círculo&lt;/em>. Opcionalmente, também recebe como argumento um &lt;em>delta tempo&lt;/em>, de modo a garantir uma uniformização das animações e dos movimentos entre diferentes dispositivos. Se este argumento for usado, as &lt;em>variações&lt;/em> das coordenadas devem ser expressas em função de um segundo &amp;mdash; i.e., &lt;em>pixels&lt;/em> por segundo; caso contrário, assume-se que a &lt;em>variação&lt;/em> é definida em função de cada iteração &amp;mdash; i.e., &lt;em>pixels&lt;/em> por chamada ao método &lt;code>desenha()&lt;/code>.
   * @param {Tela} tela Objecto que representa o elemento &lt;code>canvas&lt;/code> onde será desenhado o &lt;em>círculo&lt;/em>
   * @param {number} [deltaTempo=1] Variação temporal entre chamadas (para sincronização de animações); se não for fornecido, assume-se o valor &lt;code>1&lt;/code>.
   * @throws {TypeError} Se &lt;code>tela&lt;/code> não for uma instância de &lt;code>Tela&lt;/code>.
   * @throws {TypeError} Se &lt;code>deltaTempo&lt;/code> não for um número finito.
   * @throws {RangeError} Se o parâmetro &lt;code>deltaTempo&lt;/code> for um número negativo.
   */
  desenha(tela, deltaTempo = 1) {
    if (!(tela instanceof Tela)) {
      throw new TypeError('O parâmetro "tela" deve ser uma instância de "Tela".');
    }
    if (typeof deltaTempo !== 'number' || !Number.isFinite(deltaTempo)) {
      throw new TypeError('O parâmetro "deltaTempo" deve ser um número finito.');
    }
    if (deltaTempo &lt; 0) {
      throw new RangeError('O parâmetro "deltaTempo" não pode ser um número negativo.');
    }
    super.desenha(tela, () => {
      const contexto = tela.contexto;
      contexto.fillStyle = this.#preenchimento;
      contexto.strokeStyle = this.#contorno;
      contexto.lineWidth = this.#espessura;
      contexto.beginPath();
      contexto.arc(Math.floor(-this.centroide.x + this.#raio), Math.floor(-this.centroide.y + this.#raio), this.#raio, 0, Math.PI * 2);
      contexto.closePath();
      // ajuste translacional para que o padrão de preenchimento, quando usado, use como referência o canto superior do círculo
      contexto.translate(Math.floor(-this.centroide.x), Math.floor(-this.centroide.y));
      contexto.fill();
      if (this.#espessura > 0) {
        contexto.stroke();
      }
    }, deltaTempo);
  }
}

//

/**
 * @class
 * @extends Grafico
 * @classdesc A classe &lt;code>Rectangulo&lt;/code> é uma subclasse de &lt;code>Grafico&lt;/code>, servindo para representar &lt;em>rectângulos&lt;/em>. Num nível básico, um &lt;em>rectângulo&lt;/em> é definido por um &lt;em>ponto&lt;/em>, correspondente, regra geral, ao seu canto superior esquerdo e por uma &lt;em>largura&lt;/em> e por uma &lt;em>altura&lt;/em>.
 * @property {number} x Abscissa para posicionar o &lt;em>rectângulo&lt;/em> no &lt;code>canvas&lt;/code>.
 * @property {number} y Ordenada para posicionar o &lt;em>rectângulo&lt;/em> no &lt;code>canvas&lt;/code>.
 * @property {number} largura Largura do &lt;em>rectângulo&lt;/em>.
 * @property {number} altrura Altura do &lt;em>rectângulo&lt;/em>.
 * @property {string} preenchimento Cor ou padrão do preenchimento &lt;em>rectângulo&lt;/em>.
 * @property {string} contorno Cor ou padrão do contorno do &lt;em>rectângulo&lt;/em>.
 * @property {number} espessura Espessura do contorno do &lt;em>rectângulo&lt;/em> &amp;mdash. Se a &lt;em>espessura&lt;/em> tiver um valor igual a zero (&lt;code>0&lt;/code>), o contorno não é desenhado.
 * @property {number} deltaX=0 Variação horizontal da posição do &lt;em>rectângulo&lt;/em>, após cada iteração de desenho.
 * @property {number} deltaY=0 Variação vertical da posição do &lt;em>rectângulo&lt;/em>, após cada iteração de desenho.
 * @property {number} distX=0 Distância horizontal do &lt;em>rectângulo&lt;/em> até um dado ponto.
 * @property {number} distY=0 Distância vertical do &lt;em>rectângulo&lt;/em> até um dado ponto.
 * @property {number} gravidade=0 Força que, quando usada em conjunto com um &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação vertical do &lt;em>rectângulo&lt;/em>, actuando como a &lt;em>gravidade&lt;/em>.
 * @property {number} velocidade=0 Velocidade que, quando usada em conjunto com um &lt;em>ângulo (de rotação)&lt;/em>, pode ser utilizada para definir a variação horizontal e vertical do &lt;em>rectângulo&lt;/em>.
 * @property {number} atrito=0.0 Força que reduz o movimento (sejam os &lt;em>deltas&lt;/em> ou a &lt;em>velocidade&lt;/em>) do &lt;em>rectângulo&lt;/em>. O valor deve estar compreendido entre &lt;code>0&lt;/code> (sem atrito) e &lt;code>1&lt;/code> (movimento totalmente travado). Se o valor indicado estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code>, se inferior, ou para &lt;code>1.0&lt;/code>, se superior.
 * @property {number} anguloRotacao=0 Ângulo de rotação do &lt;em>rectângulo&lt;/em> quando desenhado no &lt;code>canvas&lt;/code>, usado também em conjunto com a &lt;em>velocidade&lt;/em>, compreendido entre &lt;code>0&lt;/code> e &lt;code>360&lt;/code> &amp;mdash; independentemente do valor atribuído, é sempre usado o &lt;em>resto&lt;/em> da sua divisão por &lt;code>360&lt;/code>. A rotação é feita tendo como referência o centro do &lt;em>rectângulo&lt;/em>.
 * @property {number} deltaRotacao=0 Variação do ângulo de rotação do &lt;em>rectângulo&lt;/em>, após cada iteração de desenho.
 * @property {number} anguloGravidade=0 Ângulo cujo co-seno afecta a aplicação do sentido da &lt;em>gravidade&lt;/em> ao &lt;em>rectângulo&lt;/em>, compreendido entre &lt;code>0&lt;/code> e &lt;code>180&lt;/code>. Se o valor indicado estiver fora deste intervalo, será corrigido para &lt;code>0&lt;/code>, se inferior, ou para &lt;code>360&lt;/code>, se superior.
 * @property {number} deltaGravidade=0 Variação do ângulo aplicado à &lt;em>gravidade&lt;/em>, após cada iteração de desenho.
 * @property {number} opacidade=1.0 Valor da opacidade do &lt;em>rectângulo&lt;/em> &amp;mdash; pode variar entre &lt;code>0.0&lt;/code> (completamente transparente) e &lt;code>1.0&lt;/code> (completamente opaco). Se o valor atribuído estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code>, se inferior, ou para &lt;code>1.0&lt;/code>, se superior.
 * @property {boolean} activo=true Indicação de que o &lt;em>rectângulo&lt;/em> deve testar colisões, quando chamado o método &lt;code>colide()&lt;/code>. Será útil quando os &lt;em>rectângulo&lt;/em> são processados em bloco, por exemplo, num &lt;em>array&lt;/em>, e nem todos devem ser testados para colisões, ou mesmo para quando há momentos em que o &lt;em>rectângulo&lt;/em> deve reagir a colisões e noutros não.
 * @property {boolean} visivel=true Indicação de que o &lt;em>rectângulo&lt;/em> deve ser desenhado no &lt;code>canvas&lt;/code>, quando chamado o método &lt;code>desenha()&lt;/code>.
 * @property {boolean} actualiza=true Indicação de que o &lt;em>rectângulo&lt;/em> deve ter o seu posicionamento actualizado após o seu &lt;em>desenho&lt;/em> na &lt;em>tela&lt;/em>.
 */
class Rectangulo extends Grafico {
  #preenchimento;
  #espessura;
  #contorno;
  #largura;
  #altura;

  /**
   * Construtor para criação de novos objectos do tipo &lt;code>Rectangulo&lt;/code>.
   * @param {number} x Abscissa para posicionar o &lt;em>rectângulo&lt;/em> no &lt;code>canvas&lt;/code>.
   * @param {number} y Ordenada para posicionar o &lt;em>rectângulo&lt;/em> no &lt;code>canvas&lt;/code>.
   * @param {number} largura Largura do &lt;em>rectângulo&lt;/em>.
   * @param {number} altura Altura do &lt;em>rectângulo&lt;/em>.
   * @param {string|CanvasPattern} [preenchimento='black'] Cor ou padrão do preenchimento do &lt;em>rectângulo&lt;/em>.
   * @param {string|CanvasPattern} [contorno='black'] Cor ou padrão do contorno do &lt;em>rectângulo&lt;/em>.
   * @param {number} [espessura=0] Espessura do contorno do &lt;em>rectângulo&lt;/em>.
   * @throws {TypeError} Se &lt;code>x&lt;/code> ou &lt;code>y&lt;/code> não forem números finitos.
   * @throws {TypeError} Se &lt;code>largura&lt;/code> ou &lt;code>altura&lt;/code> não forem números finitos e positivos.
   * @throws {TypeError} Se &lt;code>preenchimento&lt;/code> ou &lt;code>contorno&lt;/code> não forem &lt;em>strings&lt;/em> ou objectos do tipo &lt;code>CanvasPattern&lt;/code>.
   * @throws {TypeError} Se &lt;code>espessura&lt;/code> não for um número finito.
   * @throws {RangeError} Se &lt;code>espessura&lt;/code> for um número negativo.
   */
  constructor(x, y, largura, altura, preenchimento = 'black', contorno = 'black', espessura = 0) {
    if (typeof x !== 'number' || !Number.isFinite(x)) {
      throw new TypeError('O parâmetro "x" deve ser um número finito.');
    }
    if (typeof y !== 'number' || !Number.isFinite(y)) {
      throw new TypeError('O parâmetro "y" deve ser um número finito.');
    }
    if (typeof largura !== 'number' || !Number.isFinite(largura)) {
      throw new TypeError('O parâmetro "largura" deve ser um número finito.');
    }
    if (largura &lt;= 0) {
      throw new RangeError('O parâmetro "largura" deve ser um número positivo.');
    }
    if (typeof altura !== 'number' || !Number.isFinite(altura)) {
      throw new TypeError('O parâmetro "altura" deve ser um número finito.');
    }
    if (altura &lt;= 0) {
      throw new RangeError('O parâmetro "altura" deve ser um número positivo.');
    }
    if (typeof preenchimento !== 'string' &amp;&amp; !(preenchimento instanceof CanvasPattern)) {
      console.log(preenchimento)
      throw new TypeError('O parâmetro "preenchimento" deve ser uma "string" ou um objecto do tipo "CanvasPattern".');
    }
    if (typeof contorno !== 'string' &amp;&amp; !(contorno instanceof CanvasPattern)) {
      throw new TypeError('O parâmetro "contorno" deve ser uma "string" ou um objecto do tipo "CanvasPattern".');
    }
    if (typeof espessura !== 'number' || !Number.isFinite(espessura)) {
      throw new TypeError('O parâmetro "espessura" deve ser um número finito.');
    }
    if (espessura &lt; 0) {
      throw new RangeError('O parâmetro "espessura" não pode ser um número negativo.');
    }
    super(x, y);
    this.#largura = largura;
    this.#altura = altura;
    this.#preenchimento = preenchimento;
    this.#contorno = contorno;
    this.#espessura = espessura;
  }

  set largura(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "largura" deve ser um número finito.');
    }
    if (valor &lt;= 0) {
      throw new TypeError('O valor de "largura" deve ser um número positivo.');
    }
    this.#largura = valor;
  }

  get largura() {
    return this.#largura;
  }

  set altura(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "altura" deve ser um número finito.');
    }
    if (valor &lt;= 0) {
      throw new TypeError('O valor de "altura" deve ser um número positivo.');
    }
    this.#altura = valor;
  }

  get altura() {
    return this.#altura;
  }

  set preenchimento(valor) {
    if (typeof valor !== 'string' &amp;&amp; typeof valor !== 'CanvasPattern') {
      throw new TypeError('O valor de "preenchimento" deve ser uma "string" ou um objecto do tipo "CanvasPattern".');
    }
    this.#preenchimento = valor;
  }

  get preenchimento() {
    return this.#preenchimento;
  }

  set espessura(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "espessura" deve ser um número finito.');
    }
    if (valor &lt; 0) {
      throw new RangeError('O valor de "espessura" não pode ser um número negativo.');
    }
    this.#espessura = valor;
  }

  get espessura() {
    return this.#espessura;
  }

  set contorno(valor) {
    if (typeof valor !== 'string' &amp;&amp; typeof valor !== 'CanvasPattern') {
      throw new TypeError('O valor de "preenchimento" deve ser uma "string" ou um objecto do tipo "CanvasPattern".');
    }
    this.#contorno = valor;
  }

  get contorno() {
    return this.#contorno;
  }

  /**
   * Verifica se um dado &lt;em>ponto&lt;/em> está contido área do &lt;em>invólucro&lt;/em> rectangular que envolve este &lt;em>gráfico&lt;/em>. Tal acontece quando esse &lt;em>ponto&lt;/em> está compreendido entre &lt;em>x&lt;/em> e &lt;em>x mais a largura&lt;/em> e entre &lt;em>y&lt;/em> e &lt;em>y mais altura&lt;/em> desse &lt;em>invólucro&lt;/em>.
   * @param {number} x Abscissa do ponto a testar se está contido neste &lt;em>gráfico&lt;/em>.
   * @param {number} y Ordenada do ponto a testar se está contido neste &lt;em>gráfico&lt;/em>.
   * @returns {boolean} Se o ponto estiver contido neste &lt;em>gráfico&lt;/em>, &lt;code>true&lt;/code>; senão, &lt;code>false&lt;/code>.
   * @throws {TypeError} Se &lt;code>x&lt;/code> ou &lt;code>y&lt;/code> não forem números finitos.
   */
  contemPonto(x, y) {
    if (typeof x !== 'number' || !Number.isFinite(x)) {
      throw new TypeError('O parâmetro "x" deve ser um número finito.');
    }
    if (typeof y !== 'number' || !Number.isFinite(y)) {
      throw new TypeError('O parâmetro "y" deve ser um número finito.');
    }
    if (this.anguloRotacao !== 0) {
      return super.contemPonto(x, y);
    }
    else {
      return (x > this.x &amp;&amp; x &lt;= this.x + this.largura &amp;&amp; y > this.y &amp;&amp; y &lt;= this.y + this.altura);
    }
  }

  /**
   * Desenha um &lt;em>rectângulo&lt;/em> no &lt;code>canvas&lt;/code>, usando como referência de posicionamento o &lt;em>ponto&lt;/em> correspondente ao canto superior esquerdo desse &lt;em>rectângulo&lt;/em>. Opcionalmente, também recebe como argumento um &lt;em>delta tempo&lt;/em>, de modo a garantir uma uniformização das animações e dos movimentos entre diferentes dispositivos. Se este argumento for usado, as &lt;em>variações&lt;/em> das coordenadas devem ser expressas em função de um segundo &amp;mdash; i.e., &lt;em>pixels&lt;/em> por segundo; caso contrário, assume-se que a &lt;em>variação&lt;/em> é definida em função de cada iteração &amp;mdash; i.e., &lt;em>pixels&lt;/em> por chamada ao método &lt;code>desenha()&lt;/code>.
   * @param {Tela} tela Objecto que representa o elemento &lt;code>canvas&lt;/code> onde será desenhado o &lt;em>rectângulo&lt;/em>
   * @param {number} [deltaTempo=1] Variação temporal entre chamadas (para sincronização de animações); se não for fornecido, assume-se o valor &lt;code>1&lt;/code>.
   * @throws {TypeError} Se &lt;code>tela&lt;/code> não for uma instância de &lt;code>Tela&lt;/code>.
   * @throws {TypeError} Se &lt;code>deltaTempo&lt;/code> não for um número finito e positivo.
   * @throws {RangeError} Se o parâmetro &lt;code>deltaTempo&lt;/code> for um número negativo.
   */
  desenha(tela, deltaTempo = 1) {
    if (!(tela instanceof Tela)) {
      throw new TypeError('O parâmetro "tela" deve ser uma instância de "Tela".');
    }
    if (typeof deltaTempo !== 'number' || !Number.isFinite(deltaTempo)) {
      throw new TypeError('O parâmetro "deltaTempo" deve ser um número finito.');
    }
    if (deltaTempo &lt; 0) {
      throw new RangeError('O parâmetro "deltaTempo" não pode ser um número negativo.');
    }
    super.desenha(tela, () => {
      const contexto = tela.contexto;
      contexto.fillStyle = this.preenchimento;
      contexto.strokeStyle = this.contorno;
      contexto.lineWidth = this.espessura;
      contexto.beginPath();
      contexto.rect(Math.floor(-this.centroide.x), Math.floor(-this.centroide.y), this.largura, this.altura);
      contexto.closePath();
      // ajuste translacional para que o padrão de preenchimento, quando usado, use como referência o canto superior do rectângulo
      contexto.translate(Math.floor(-this.centroide.x), Math.floor(-this.centroide.y));
      contexto.fill();
      if (this.espessura > 0) {
        contexto.stroke();
      }
    }, deltaTempo);
  }
}

//

/**
 * @class
 * @extends Grafico
 * @classdesc A classe &lt;code>Poligono&lt;/code> é uma subclasse de &lt;code>Grafico&lt;/code>, servindo para representar &lt;em>polígonos&lt;/em>. Num nível básico, um &lt;em>polígono&lt;/em> é definido por um &lt;em>ponto&lt;/em>, correspondente, regra geral, ao canto superior esquerdo de um &lt;em>rectângulo imaginário&lt;/em> que contenha o &lt;em>polígono&lt;/em>. Assim, este será o &lt;em>ponto&lt;/em> relativamente ao qual todos os pontos do &lt;em>polígono&lt;/em> serão posicionados. Aconselha-se que todos os pontos do polígono se encontrem à direita e abaixo desta origem e tão próximos dela quanto possível; caso contrário, aspectos como a rotação do polígono poderão ter resultados diferentes do esperado. Deste modo, há a possibilidade, activada por omissão, através do atributo &lt;code>justo&lt;/code>, de &lt;em>encostar&lt;/em> o polígono à origem &amp;mdash; contudo, tal implica a alteração (o &lt;em>ajuste&lt;/em>) de todos os pontos.
 * @property {number} x Abscissa para posicionar o &lt;em>polígono&lt;/em> no &lt;code>canvas&lt;/code>.
 * @property {number} y Ordenada para posicionar o &lt;em>polígono&lt;/em> no &lt;code>canvas&lt;/code>.
 * @property {array} vertices Conjunto de pontos com os vários vértices do &lt;em>polígono&lt;/em>
 * @property {string} preenchimento Cor ou padrão do preenchimento &lt;em>polígono&lt;/em>.
 * @property {string} contorno Cor ou padrão do contorno do &lt;em>polígono&lt;/em>.
 * @property {number} espessura Espessura do contorno do &lt;em>polígono&lt;/em> &amp;mdash. Se a &lt;em>espessura&lt;/em> tiver um valor igual a zero (&lt;code>0&lt;/code>), o contorno não é desenhado.
 * @property {number} deltaX=0 Variação horizontal da posição do &lt;em>polígono&lt;/em>, após cada iteração de desenho.
 * @property {number} deltaY=0 Variação vertical da posição do &lt;em>polígono&lt;/em>, após cada iteração de desenho.
 * @property {number} distX=0 Distância horizontal do &lt;em>polígono&lt;/em> até um dado ponto.
 * @property {number} distY=0 Distância vertical do &lt;em>polígono&lt;/em> até um dado ponto.
 * @property {number} gravidade=0 Força que, quando usada em conjunto com um &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação vertical do &lt;em>polígono&lt;/em>, actuando como a &lt;em>gravidade&lt;/em>.
 * @property {number} velocidade=0 Velocidade que, quando usada em conjunto com um &lt;em>ângulo (de rotação)&lt;/em>, pode ser utilizada para definir a variação horizontal e vertical do &lt;em>polígono&lt;/em>.
 * @property {number} atrito=0.0 Força que reduz o movimento (sejam os &lt;em>deltas&lt;/em> ou a &lt;em>velocidade&lt;/em>) do &lt;em>polígono&lt;/em>. O valor deve estar compreendido entre &lt;code>0&lt;/code> (sem atrito) e &lt;code>1&lt;/code> (movimento totalmente travado). Se o valor indicado estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code>, se inferior, ou para &lt;code>1.0&lt;/code>, se superior.
 * @property {number} anguloRotacao=0 Ângulo de rotação do &lt;em>polígono&lt;/em> quando desenhado no &lt;code>canvas&lt;/code>, usado também em conjunto com a &lt;em>velocidade&lt;/em>, compreendido entre &lt;code>0&lt;/code> e &lt;code>360&lt;/code> &amp;mdash; independentemente do valor atribuído, é sempre usado o &lt;em>resto&lt;/em> da sua divisão por &lt;code>360&lt;/code>. A rotação é feita tendo como referência o centro do &lt;em>polígono&lt;/em>.
 * @property {number} deltaRotacao=0 Variação do ângulo de rotação do &lt;em>polígono&lt;/em>, após cada iteração de desenho.
 * @property {number} anguloGravidade=0 Ângulo cujo co-seno afecta a aplicação do sentido da &lt;em>gravidade&lt;/em> ao &lt;em>polígono&lt;/em>, compreendido entre &lt;code>0&lt;/code> e &lt;code>180&lt;/code>. Se o valor indicado estiver fora deste intervalo, será corrigido para &lt;code>0&lt;/code>, se inferior, ou para &lt;code>360&lt;/code>, se superior.
 * @property {number} deltaGravidade=0 Variação do ângulo aplicado à &lt;em>gravidade&lt;/em>, após cada iteração de desenho.
 * @property {number} opacidade=1.0 Valor da opacidade do &lt;em>polígono&lt;/em> &amp;mdash; pode variar entre &lt;code>0.0&lt;/code> (completamente transparente) e &lt;code>1.0&lt;/code> (completamente opaco). Se o valor atribuído estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code>, se inferior, ou para &lt;code>1.0&lt;/code>, se superior.
 * @property {boolean} activo=true Indicação de que o &lt;em>polígono&lt;/em> deve testar colisões, quando chamado o método &lt;code>colide()&lt;/code>. Será útil quando os &lt;em>polígono&lt;/em> são processados em bloco, por exemplo, num &lt;em>array&lt;/em>, e nem todos devem ser testados para colisões, ou mesmo para quando há momentos em que o &lt;em>polígono&lt;/em> deve reagir a colisões e noutros não.
 * @property {boolean} visivel=true Indicação de que o &lt;em>polígono&lt;/em> deve ser desenhado no &lt;code>canvas&lt;/code>, quando chamado o método &lt;code>desenha()&lt;/code>.
 * @property {boolean} actualiza=true Indicação de que o &lt;em>polígono&lt;/em> deve ter o seu posicionamento actualizado após o seu &lt;em>desenho&lt;/em> na &lt;em>tela&lt;/em>.
 */
class Poligono extends Grafico {
  #preenchimento;
  #espessura;
  #contorno;
  #vertices;
  #deslocX;
  #deslocY;
  #justo;

  /**
   * Construtor para criação de novos objectos do tipo &lt;code>Poligono&lt;/code>.
   * @param {number} x Abscissa para posicionar o &lt;em>polígono&lt;/em> no &lt;code>canvas&lt;/code>.
   * @param {number} y Ordenada para posicionar o &lt;em>polígono&lt;/em> no &lt;code>canvas&lt;/code>.
   * @param {Array&lt;{x: number, y: number}>} vertices Conjunto de pontos com os vários vértices do &lt;em>polígono&lt;/em>.
   * @param {string|CanvasPattern} [preenchimento='black'] Cor ou padrão do preenchimento do &lt;em>polígono&lt;/em>.
   * @param {string|CanvasPattern} [contorno='black'] Cor ou padrão do contorno do &lt;em>polígono&lt;/em>.
   * @param {number} [espessura=0] Espessura do contorno do &lt;em>polígono&lt;/em>.
   * @param {boolean} [justo=true] Indicação de que o &lt;em>polígono&lt;/em> deve ser reposicionado de forma a ficar &lt;em>encostado&lt;/em> ao ponto usado para definir o seu posicionamento no &lt;code>canvas&lt;/code>.
   * @throws {TypeError} Se &lt;code>x&lt;/code> ou &lt;code>y&lt;/code> não forem números finitos.
   * @throws {TypeError} Se &lt;code>vertices&lt;/code> não for um "array" com pelo menos 3 pontos válidos.
   * @throws {TypeError} Se cada vértice não for um objecto com propriedades numéricas &lt;code>x&lt;/code> e &lt;code>y&lt;/code>.
   * @throws {TypeError} Se &lt;code>preenchimento&lt;/code> ou &lt;code>contorno&lt;/code> não forem &lt;em>strings&lt;/em> ou objectos do tipo &lt;code>CanvasPattern&lt;/code>.
   * @throws {TypeError} Se &lt;code>espessura&lt;/code> não for um número finito.
   * @throws {RangeError} Se &lt;code>espessura&lt;/code> for um número negativo.
   * @throws {TypeError} Se &lt;code>justo&lt;/code> não for um valor booleano.
   */
  constructor(x, y, vertices, preenchimento = 'black', contorno = 'black', espessura = 0, justo = true) {
    if (typeof x !== 'number' || !Number.isFinite(x)) {
      throw new TypeError('O parâmetro "x" deve ser um número finito.');
    }
    if (typeof y !== 'number' || !Number.isFinite(y)) {
      throw new TypeError('O parâmetro "y" deve ser um número finito.');
    }
    if (!Array.isArray(vertices) || vertices.length &lt; 3) {
      throw new TypeError('O parâmetro "vertices" deve ser um "array" com pelo menos 3 pontos.');
    }
    for (const vertice of vertices) {
      if (typeof vertice !== 'object' || typeof vertice.x !== 'number' || !Number.isFinite(vertice.x) || typeof vertice.y !== 'number' || !Number.isFinite(vertice.y)) {
        throw new TypeError('Cada elemento de "vertices" deve ser um objecto com propriedades numéricas "x" e "y".');
      }
    }
    if (typeof preenchimento !== 'string' &amp;&amp; !(preenchimento instanceof CanvasPattern)) {
      console.log(preenchimento)
      throw new TypeError('O parâmetro "preenchimento" deve ser uma "string" ou um objecto do tipo "CanvasPattern".');
    }
    if (typeof contorno !== 'string' &amp;&amp; !(contorno instanceof CanvasPattern)) {
      throw new TypeError('O parâmetro "contorno" deve ser uma "string" ou um objecto do tipo "CanvasPattern".');
    }
    if (typeof espessura !== 'number' || !Number.isFinite(espessura)) {
      throw new TypeError('O parâmetro "espessura" deve ser um número finito.');
    }
    if (espessura &lt; 0) {
      throw new RangeError('O parâmetro "espessura" não pode ser um número negativo.');
    }
    if (typeof justo !== 'boolean') {
      throw new TypeError('O parâmetro "justo" deve ser um valor booleano.');
    }
    super(x, y);
    this.#vertices = vertices.map(vertice => ({ x: vertice.x, y: vertice.y }));
    this.#preenchimento = preenchimento;
    this.#contorno = contorno;
    this.#espessura = espessura;
    this.#justo = justo;
    this.#deslocX = 0;
    this.#deslocY = 0;
    // se justo for verdadeiro (true), todo os pontos são alterados de forma a que o polígono seja 'encostado' à origem: o ponto (x, y) do polígono
    this.#ajusta();
  }

  set preenchimento(valor) {
    if (typeof valor !== 'string' &amp;&amp; typeof valor !== 'CanvasPattern') {
      throw new TypeError('O valor de "preenchimento" deve ser uma "string" ou um objecto do tipo "CanvasPattern".');
    }
    this.#preenchimento = valor;
  }

  get preenchimento() {
    return this.#preenchimento;
  }

  set espessura(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "espessura" deve ser um número finito.');
    }
    if (valor &lt; 0) {
      throw new RangeError('O valor de "espessura" não pode ser um número negativo.');
    }
    this.#espessura = valor;
  }

  get espessura() {
    return this.#espessura;
  }

  set contorno(valor) {
    if (typeof valor !== 'string' &amp;&amp; typeof valor !== 'CanvasPattern') {
      throw new TypeError('O valor de "preenchimento" deve ser uma "string" ou um objecto do tipo "CanvasPattern".');
    }
    this.#contorno = valor;
  }

  get contorno() {
    return this.#contorno;
  }

  set justo(valor) {
    if (typeof valor !== 'boolean') {
      throw new TypeError('O valor de "justo" deve booleano.');
    }
    this.#justo = valor;
    this.#ajusta();
  }

  get justo() {
    return this.#justo;
  }

  set vertices(valor) {
    if (!Array.isArray(valor) || valor.length &lt; 3) {
      throw new TypeError('O valor de "vertices" deve ser um "array" com pelo menos 3 pontos.');
    }
    for (const vertice of valor) {
      if (typeof vertice !== 'object' || typeof vertice.x !== 'number' || !Number.isFinite(vertice.x) || typeof vertice.y !== 'number' || !Number.isFinite(vertice.y)) {
      }
    }
    this.#vertices = valor.map(vertice => ({ x: vertice.x, y: vertice.y }));
    if (this.#justo) {
      this.#ajusta();
    }
  }

  get vertices() {
    return this.#vertices;
  }

  /**
   * Conjunto de pontos que delimitam o &lt;em>polígono&lt;/em>, definindo o seu &lt;em>invólucro&lt;/em> actual (já com rotação e translação aplicadas).
   * @type {Array&lt;{x: number, y: number}>}
   * @readonly
   */
  get involucro() {
    let verticesCartesianos = this.#vertices;
    let verticesPolares = new Array(verticesCartesianos.length);
    for (let i = 0; i &lt; verticesPolares.length; i++) {
      verticesPolares[i] = Grafico.calculaCoordenadasPolares(this.#vertices[i].x - this.centroide.x, this.#vertices[i].y - this.centroide.y);
    }
    let involucro = new Array(verticesPolares.length);
    for (let i = 0; i &lt; involucro.length; i++) {
      involucro[i] = { x: Grafico.calculaCoordenadasCartesianas(verticesPolares[i].distancia, verticesPolares[i].angulo + this.anguloRotacao).x + this.centroide.x + this.x, y: Grafico.calculaCoordenadasCartesianas(verticesPolares[i].distancia, verticesPolares[i].angulo + this.anguloRotacao).y + this.centroide.y + this.y };
    }
    return involucro;
  }

  // este método privado ajusta o polígono de forma a ficar encostado ao ponto usado para definir o seu posicionamento no canvas (ou desfaz o ajuste que lhe possa ter sido aplicado, revertendo-o ao seu posicionamento original)
  #ajusta() {
    if (this.justo) {
      let deslocX = Number.POSITIVE_INFINITY;
      let deslocY = Number.POSITIVE_INFINITY;
      for (let i = 0; i &lt; this.#vertices.length; i++) {
        deslocX = Math.min(deslocX, this.#vertices[i].x);
        deslocY = Math.min(deslocY, this.#vertices[i].y);
      }
      this.#deslocX = deslocX;
      this.#deslocY = deslocY;
      for (let i = 0; i &lt; this.#vertices.length; i++) {
        this.#vertices[i].x -= deslocX;
        this.#vertices[i].y -= deslocY;
      }
    }
    else {
      for (let i = 0; i &lt; this.#vertices.length; i++) {
        this.#vertices[i].x += this.#deslocX;
        this.#vertices[i].y += this.#deslocY;
      }
      this.#deslocX = 0;
      this.#deslocY = 0;
    }
  }

  /**
   * Largura do menor &lt;em>rectângulo imaginário&lt;/em> que envolve este &lt;em>polígono&lt;/em>. É definida pela distância entre o &lt;em>x&lt;/em> do ponto mais à esquerda e o &lt;em>x&lt;/em> do ponto mais à direita do &lt;em>polígono&lt;/em>.
   * @type {number}
   * @readonly
   */
  get largura() {
    if (this.#vertices.length === 0) {
      return 0;
    }
    else {
      let minX = Number.POSITIVE_INFINITY;
      let maxX = Number.NEGATIVE_INFINITY;
      for (let ponto of this.#vertices) {
        minX = Math.min(minX, ponto.x);
        maxX = Math.max(maxX, ponto.x);
      }
      return maxX - minX;
    }
  }

  /**
   * Altura do menor &lt;em>rectângulo imaginário&lt;/em> que envolva este &lt;em>polígono&lt;/em>. É definida pela distância entre o &lt;em>y&lt;/em> do ponto mais acima e o &lt;em>y&lt;/em> do ponto mais abaixo do &lt;em>polígono&lt;/em>.
   * @type {number}
   * @readonly
   */
  get altura() {
    if (this.#vertices.length === 0) {
      return 0;
    }
    else {
      let minY = Number.POSITIVE_INFINITY;
      let maxY = Number.NEGATIVE_INFINITY;
      for (let ponto of this.#vertices) {
        minY = Math.min(minY, ponto.y);
        maxY = Math.max(maxY, ponto.y);
      }
      return maxY - minY;
    }
  }

  /**
   * Centróide do &lt;em>polígono&lt;/em>, calculado a partir dos seus vértices usando a fórmula da área de Gauss.
   * @type {{x: number, y: number}}
   * @readonly
   */
  get centroide() {
    let somatorioArea = 0, somatorioCentroideX = 0, somatorioCentroideY = 0;
    let area = 0, centroideX = 0, centroideY = 0;
    if (this.#vertices.length > 2) {
      for (let i = 0, j = this.#vertices.length - 1; i &lt; this.#vertices.length; j = i++) {
        let xi = this.#vertices[i].x, yi = this.#vertices[i].y;
        let xj = this.#vertices[j].x, yj = this.#vertices[j].y;
        let produtoCruzado = xi * yj - xj * yi;
        somatorioArea += produtoCruzado;
        somatorioCentroideX += (xi + xj) * produtoCruzado;
        somatorioCentroideY += (yi + yj) * produtoCruzado;
      }
      area = (1 / 2) * somatorioArea;
    }
    if (area !== 0) {
      centroideX = (1 / (6 * area)) * somatorioCentroideX;
      centroideY = (1 / (6 * area)) * somatorioCentroideY;
    }
    return { x: centroideX, y: centroideY };
  }

  /**
   * Desenha um &lt;em>polígono&lt;/em> no &lt;code>canvas&lt;/code>, usando como referência de posicionamento o &lt;em>ponto&lt;/em> correspondente ao canto superior esquerdo de um &lt;em>rectângulo imaginário&lt;/em> que contenha o &lt;em>polígono&lt;/em>. Opcionalmente, também recebe como argumento um &lt;em>delta tempo&lt;/em>, de modo a garantir uma uniformização das animações e dos movimentos entre diferentes dispositivos. Se este argumento for usado, as &lt;em>variações&lt;/em> das coordenadas devem ser expressas em função de um segundo &amp;mdash; i.e., &lt;em>pixels&lt;/em> por segundo; caso contrário, assume-se que a &lt;em>variação&lt;/em> é definida em função de cada iteração &amp;mdash; i.e., &lt;em>pixels&lt;/em> por chamada ao método &lt;code>desenha()&lt;/code>.
   * @param {Tela} tela Objecto que representa o elemento &lt;code>canvas&lt;/code> onde será desenhado o &lt;em>polígono&lt;/em>
   * @param {number} [deltaTempo=1] Variação temporal entre chamadas (para sincronização de animações); se não for fornecido, assume-se o valor &lt;code>1&lt;/code>.
   * @throws {TypeError} Se &lt;code>tela&lt;/code> não for uma instância de &lt;code>Tela&lt;/code>.
   * @throws {TypeError} Se &lt;code>deltaTempo&lt;/code> não for um número finito e positivo.
   * @throws {RangeError} Se o parâmetro &lt;code>deltaTempo&lt;/code> for um número negativo.
   */
  desenha(tela, deltaTempo = 1) {
    if (!(tela instanceof Tela)) {
      throw new TypeError('O parâmetro "tela" deve ser uma instância de "Tela".');
    }
    if (typeof deltaTempo !== 'number' || !Number.isFinite(deltaTempo)) {
      throw new TypeError('O parâmetro "deltaTempo" deve ser um número finito.');
    }
    if (deltaTempo &lt; 0) {
      throw new RangeError('O parâmetro "deltaTempo" não pode ser um número negativo.');
    }
    super.desenha(tela, () => {
      const contexto = tela.contexto;
      contexto.fillStyle = this.#preenchimento;
      contexto.strokeStyle = this.#contorno;
      contexto.lineWidth = this.#espessura;
      contexto.beginPath();
      for (let i = 0; i &lt; this.#vertices.length; i++) {
        if (i === 0) {
          contexto.moveTo(Math.floor(this.#vertices[i].x - this.centroide.x), Math.floor(this.#vertices[i].y - this.centroide.y));
        }
        else {
          contexto.lineTo(Math.floor(this.#vertices[i].x - this.centroide.x), Math.floor(this.#vertices[i].y - this.centroide.y));
        }
      }
      contexto.closePath();
      // ajuste translacional para que o padrão de preenchimento, quando usado, use como referência o canto superior do polígono
      contexto.translate(Math.floor(-this.centroide.x), Math.floor(-this.centroide.y));
      contexto.fill();
      if (this.#espessura > 0) {
        contexto.stroke();
      }
    }, deltaTempo);
  }
}

//

/**
 * @class
 * @extends Grafico
 * @classdesc A classe &lt;code>Texto&lt;/code> é uma subclasse de &lt;code>Grafico&lt;/code>, servindo para representar uma ou mais linhas de &lt;em>texto&lt;/em>. Se o &lt;em>texto&lt;/em> tiver mais que uma linha, estes devem estar separadas por &lt;code>/n&lt;/code>.
 * @property {number} x Abscissa para posicionar o &lt;em>texto&lt;/em> no &lt;code>canvas&lt;/code>.
 * @property {number} y Ordenada para posicionar o &lt;em>texto&lt;/em> no &lt;code>canvas&lt;/code>.
 * @property {number} tamanho=16 Tamanho do &lt;em>texto&lt;/em> em pontos (&lt;code>pt&lt;/code)
 * @property {number} fonte='sans-serif' Fonte do &lt;em>texto&lt;/em>.
 * @property {string} preenchimento Cor ou padrão do preenchimento &lt;em>texto&lt;/em>.
 * @property {string} contorno Cor ou padrão do contorno do &lt;em>texto&lt;/em>.
 * @property {number} espessura Espessura do contorno do &lt;em>texto&lt;/em> &amp;mdash. Se a &lt;em>espessura&lt;/em> tiver um valor igual a zero (&lt;code>0&lt;/code>), o contorno não é desenhado.
 * @property {number} deltaX=0 Variação horizontal da posição do &lt;em>texto&lt;/em>, após cada iteração de desenho.
 * @property {number} deltaY=0 Variação vertical da posição do &lt;em>texto&lt;/em>, após cada iteração de desenho.
 * @property {number} distX=0 Distância horizontal do &lt;em>texto&lt;/em> até um dado ponto.
 * @property {number} distY=0 Distância vertical do &lt;em>texto&lt;/em> até um dado ponto.
 * @property {number} gravidade=0 Força que, quando usada em conjunto com um &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação vertical do &lt;em>texto&lt;/em>, actuando como a &lt;em>gravidade&lt;/em>.
 * @property {number} velocidade=0 Velocidade que, quando usada em conjunto com um &lt;em>ângulo (de rotação)&lt;/em>, pode ser utilizada para definir a variação horizontal e vertical do &lt;em>texto&lt;/em>.
 * @property {number} atrito=0.0 Força que reduz o movimento (sejam os &lt;em>deltas&lt;/em> ou a &lt;em>velocidade&lt;/em>) do &lt;em>texto&lt;/em>. O valor deve estar compreendido entre &lt;code>0&lt;/code> (sem atrito) e &lt;code>1&lt;/code> (movimento totalmente travado). Se o valor indicado estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code>, se inferior, ou para &lt;code>1.0&lt;/code>, se superior.
 * @property {number} anguloRotacao=0 Ângulo de rotação do &lt;em>texto&lt;/em> quando desenhado no &lt;code>canvas&lt;/code>, usado também em conjunto com a &lt;em>velocidade&lt;/em>, compreendido entre &lt;code>0&lt;/code> e &lt;code>360&lt;/code> &amp;mdash; independentemente do valor atribuído, é sempre usado o &lt;em>resto&lt;/em> da sua divisão por &lt;code>360&lt;/code>. A rotação é feita tendo como referência o centro do &lt;em>texto&lt;/em>.
 * @property {number} deltaRotacao=0 Variação do ângulo de rotação do &lt;em>texto&lt;/em>, após cada iteração de desenho.
 * @property {number} anguloGravidade=0 Ângulo cujo co-seno afecta a aplicação do sentido da &lt;em>gravidade&lt;/em> ao &lt;em>texto&lt;/em>, compreendido entre &lt;code>0&lt;/code> e &lt;code>180&lt;/code>. Se o valor indicado estiver fora deste intervalo, será corrigido para &lt;code>0&lt;/code>, se inferior, ou para &lt;code>360&lt;/code>, se superior.
 * @property {number} deltaGravidade=0 Variação do ângulo aplicado à &lt;em>gravidade&lt;/em>, após cada iteração de desenho.
 * @property {number} opacidade=1.0 Valor da opacidade do &lt;em>texto&lt;/em> &amp;mdash; pode variar entre &lt;code>0.0&lt;/code> (completamente transparente) e &lt;code>1.0&lt;/code> (completamente opaco). Se o valor atribuído estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code>, se inferior, ou para &lt;code>1.0&lt;/code>, se superior.
 * @property {boolean} activo=true Indicação de que o &lt;em>texto&lt;/em> deve testar colisões, quando chamado o método &lt;code>colide()&lt;/code>. Será útil quando os &lt;em>texto&lt;/em> são processados em bloco, por exemplo, num &lt;em>array&lt;/em>, e nem todos devem ser testados para colisões, ou mesmo para quando há momentos em que o &lt;em>texto&lt;/em> deve reagir a colisões e noutros não.
 * @property {boolean} visivel=true Indicação de que o &lt;em>texto&lt;/em> deve ser desenhado no &lt;code>canvas&lt;/code>, quando chamado o método &lt;code>desenha()&lt;/code>.
 * @property {boolean} actualiza=true Indicação de que o &lt;em>texto&lt;/em> deve ter o seu posicionamento actualizado após o seu &lt;em>desenho&lt;/em> na &lt;em>tela&lt;/em>.
 */
class Texto extends Grafico {
  #tamanho;
  #texto;
  #fonte;
  #preenchimento;
  #contorno;
  #espessura;

  /**
   * Construtor para criação de novos objectos do tipo &lt;code>Texto&lt;/code>.
   * @param {number} x Abscissa para posicionar o &lt;em>texto&lt;/em> no &lt;code>canvas&lt;/code>.
   * @param {number} y Ordenada para posicionar o &lt;em>texto&lt;/em> no &lt;code>canvas&lt;/code>.
   * @param {string} texto Conteúdo de &lt;em>texto&lt;/em> a desenhar no &lt;code>canvas&lt;/code>.
   * @param {string|CanvasPattern} [preenchimento='black'] Cor ou padrão do preenchimento do &lt;em>texto&lt;/em>.
   * @param {string|CanvasPattern} [contorno='black'] Cor ou padrão do contorno do &lt;em>texto&lt;/em>.
   * @param {number} [espessura=0] Espessura do contorno do &lt;em>texto&lt;/em>.
   * @param {number} [tamanho=16] Tamanho da fonte do &lt;em>texto&lt;/em> (em &lt;em>pixels&lt;/em>).
   * @param {string} [fonte='sans-serif'] Nome da fonte a utilizar para o &lt;em>texto&lt;/em>.
   * @throws {TypeError} Se &lt;code>x&lt;/code> ou &lt;code>y&lt;/code> não forem números finitos.
   * @throws {TypeError} Se &lt;code>texto&lt;/code> não for uma &lt;em>string&lt;/em>.
   * @throws {TypeError} Se &lt;code>preenchimento&lt;/code> ou &lt;code>contorno&lt;/code> não forem &lt;em>strings&lt;/em> ou objectos do tipo &lt;code>CanvasPattern&lt;/code>.
   * @throws {TypeError} Se &lt;code>espessura&lt;/code> não for um número finito.
   * @throws {RangeError} Se &lt;code>espessura&lt;/code> for um número negativo.
   * @throws {TypeError} Se &lt;code>tamanho&lt;/code> não for um número finito.
   * @throws {RangeError} Se &lt;code>tamanho&lt;/code> não for positivo.
   * @throws {TypeError} Se &lt;code>fonte&lt;/code> não for uma &lt;em>string&lt;/em> não vazia.
   */
  constructor(x, y, texto, preenchimento = 'black', contorno = 'black', espessura = 0, tamanho = 16, fonte = 'sans-serif') {
    if (typeof x !== 'number' || !Number.isFinite(x)) {
      throw new TypeError('O parâmetro "x" deve ser um número finito.');
    }
    if (typeof y !== 'number' || !Number.isFinite(y)) {
      throw new TypeError('O parâmetro "y" deve ser um número finito.');
    }
    if (typeof texto !== 'string') {
      throw new TypeError('O parâmetro "texto" deve ser uma "string".');
    }
    if (typeof preenchimento !== 'string' &amp;&amp; !(preenchimento instanceof CanvasPattern)) {
      console.log(preenchimento)
      throw new TypeError('O parâmetro "preenchimento" deve ser uma "string" ou um objecto do tipo "CanvasPattern".');
    }
    if (typeof contorno !== 'string' &amp;&amp; !(contorno instanceof CanvasPattern)) {
      throw new TypeError('O parâmetro "contorno" deve ser uma "string" ou um objecto do tipo "CanvasPattern".');
    }
    if (typeof espessura !== 'number' || !Number.isFinite(espessura)) {
      throw new TypeError('O parâmetro "espessura" deve ser um número finito.');
    }
    if (espessura &lt; 0) {
      throw new RangeError('O parâmetro "espessura" não pode ser um número negativo.');
    }
    if (typeof tamanho !== 'number' || !Number.isFinite(tamanho)) {
      throw new TypeError('O parâmetro "tamanho" deve ser um número finito.');
    }
    if (tamanho &lt;= 0) {
      throw new RangeError('O parâmetro "tamanho" deve ser um número positivo.');
    }
    if (typeof fonte !== 'string' || fonte.trim() === '') {
      throw new TypeError('O parâmetro "fonte" deve ser uma "string" não vazia.');
    }
    super(x, y);
    this.#texto = texto;
    this.#preenchimento = preenchimento;
    this.#contorno = contorno;
    this.#espessura = espessura;
    this.#tamanho = tamanho;
    this.#fonte = fonte;
  }

  set texto(valor) {
    if (typeof valor !== 'string') {
      throw new TypeError('O valor de "texto" deve ser uma "string".');
    }
    this.#texto = valor;
  }

  get texto() {
    return this.#texto;
  }

  set tamanho(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "tamanho" deve ser um número finito.');
    }
    if (valor &lt;= 0) {
      throw new RangeError('O valor de "tamanho" deve ser um número positivo.');
    }
    this.#tamanho = valor;
  }

  get tamanho() {
    return this.#tamanho;
  }

  set fonte(valor) {
    if (typeof valor !== 'string' || valor.trim() === '') {
      throw new TypeError('O valor de "fonte" deve ser uma "string" não vazia.');
    }
    this.#fonte = valor;
  }

  get fonte() {
    return this.#fonte;
  }

  set preenchimento(valor) {
    if (typeof valor !== 'string' &amp;&amp; typeof valor !== 'CanvasPattern') {
      throw new TypeError('O valor de "preenchimento" deve ser uma "string" ou um objecto do tipo "CanvasPattern".');
    }
    this.#preenchimento = valor;
  }

  get preenchimento() {
    return this.#preenchimento;
  }

  set espessura(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "espessura" deve ser um número finito.');
    }
    if (valor &lt; 0) {
      throw new RangeError('O valor de "espessura" de ser um número não negativo.');
    }
    this.#espessura = valor;
  }

  get espessura() {
    return this.#espessura;
  }

  set contorno(valor) {
    if (typeof valor !== 'string' &amp;&amp; typeof valor !== 'CanvasPattern') {
      throw new TypeError('O valor de "preenchimento" deve ser uma "string" ou um objecto do tipo "CanvasPattern".');
    }
    this.#contorno = valor;
  }

  get contorno() {
    return this.#contorno;
  }

  /**
   * Largura do &lt;em>texto&lt;/em>, definida pelo número de &lt;em>pixels&lt;/em> ocupados horizontalmente.
   * @type {number}
   * @readonly
   */
  get largura() {
    let tela = document.createElement('canvas');
    let contexto = tela.getContext('2d');
    contexto.font = this.#tamanho + 'px ' + this.#fonte;
    return contexto.measureText(this.#texto).width;
  }

  /**
   * Altura do &lt;em>texto&lt;/em>, definida pelo tamanho da fonte (em &lt;em>pixels&lt;/em>).
   * @type {number}
   * @readonly
   */
  get altura() {
    return this.#tamanho;
  }

  /**
   * Desenha uma ou mais linhas de &lt;em>texto&lt;/em> no &lt;code>canvas&lt;/code>, usando como referência de posicionamento o &lt;em>ponto&lt;/em> correspondente ao canto superior esquerdo de um &lt;em>rectângulo imaginário&lt;/em> que contenha o &lt;em>texto&lt;/em>. Opcionalmente, também recebe como argumento um &lt;em>delta tempo&lt;/em>, de modo a garantir uma uniformização das animações e dos movimentos entre diferentes dispositivos. Se este argumento for usado, as &lt;em>variações&lt;/em> das coordenadas devem ser expressas em função de um segundo &amp;mdash; i.e., &lt;em>pixels&lt;/em> por segundo; caso contrário, assume-se que a &lt;em>variação&lt;/em> é definida em função de cada iteração &amp;mdash; i.e., &lt;em>pixels&lt;/em> por chamada ao método &lt;code>desenha()&lt;/code>.
   * @param {Tela} tela Objecto que representa o elemento &lt;code>canvas&lt;/code> onde será desenhado o &lt;em>texto&lt;/em>
   * @param {number} [deltaTempo=1] Variação temporal entre chamadas (para sincronização de animações); se não for fornecido, assume-se o valor &lt;code>1&lt;/code>.
   * @throws {TypeError} Se &lt;code>tela&lt;/code> não for uma instância de &lt;code>Tela&lt;/code>.
   * @throws {TypeError} Se &lt;code>deltaTempo&lt;/code> não for um número finito e positivo.
   * @throws {RangeError} Se o parâmetro &lt;code>deltaTempo&lt;/code> for um número negativo.
   */
  desenha(tela, deltaTempo = 1) {
    if (!(tela instanceof Tela)) {
      throw new TypeError('O parâmetro "tela" deve ser uma instância de "Tela".');
    }
    if (typeof deltaTempo !== 'number' || !Number.isFinite(deltaTempo)) {
      throw new TypeError('O parâmetro "deltaTempo" deve ser um número finito.');
    }
    if (deltaTempo &lt; 0) {
      throw new RangeError('O parâmetro "deltaTempo" não pode ser um número negativo.');
    }
    super.desenha(tela, () => {
      const contexto = tela.contexto;
      contexto.fillStyle = this.#preenchimento;
      contexto.strokeStyle = this.#contorno;
      contexto.lineWidth = this.espessura;
      contexto.textBaseline = 'top';
      contexto.font = this.#tamanho + 'px ' + this.#fonte;
      let linhas = this.#texto.split('\n');
      for (let i = 0; i &lt; linhas.length; i++) {
        contexto.fillText(linhas[i], Math.floor(-this.largura * 0.5), Math.floor(-this.altura * 0.5 + i * this.#tamanho));
        if (this.espessura > 0) {
          contexto.strokeText(linhas[i], Math.floor(-this.largura * 0.5), Math.floor(-this.altura * 0.5 + i * this.#tamanho));
        }
      }
    }, deltaTempo);
  }
}

//

/**
 * @class
 * @extends Grafico
 * @classdesc A classe &lt;code>Imagem&lt;/code> é uma subclasse de &lt;code>Grafico&lt;/code>, servindo para representar &lt;em>imagens&lt;/em>. Num nível básico, uma &lt;em>imagem&lt;/em> é definida por um &lt;em>ponto&lt;/em>, correspondente, regra geral, ao seu canto superior esquerdo e pela própria imagem.
 * @property {number} x Abscissa para posicionar a &lt;em>imagem&lt;/em> no &lt;code>canvas&lt;/code>.
 * @property {number} y Ordenada para posicionar a &lt;em>imagem&lt;/em> no &lt;code>canvas&lt;/code>.
 * @property {HTMLImageElement} imagem Elemento HTML que contém a &lt;em>imagem&lt;/em>
 * @property {number} deltaX=0 Variação horizontal da posição da &lt;em>imagem&lt;/em>, após cada iteração de desenho.
 * @property {number} deltaY=0 Variação vertical da posição da &lt;em>imagem&lt;/em>, após cada iteração de desenho.
 * @property {number} distX=0 Distância horizontal da &lt;em>imagem&lt;/em> até um dado ponto.
 * @property {number} distY=0 Distância vertical da &lt;em>imagem&lt;/em> até um dado ponto.
 * @property {number} gravidade=0 Força que, quando usada em conjunto com um &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação vertical da &lt;em>imagem&lt;/em>, actuando como a &lt;em>gravidade&lt;/em>.
 * @property {number} velocidade=0 Velocidade que, quando usada em conjunto com um &lt;em>ângulo (de rotação)&lt;/em>, pode ser utilizada para definir a variação horizontal e vertical da &lt;em>imagem&lt;/em>.
 * @property {number} atrito=0.0 Força que reduz o movimento (sejam os &lt;em>deltas&lt;/em> ou a &lt;em>velocidade&lt;/em>) da &lt;em>imagem&lt;/em>. O valor deve estar compreendido entre &lt;code>0&lt;/code> (sem atrito) e &lt;code>1&lt;/code> (movimento totalmente travado). Se o valor indicado estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code>, se inferior, ou para &lt;code>1.0&lt;/code>, se superior.
 * @property {number} anguloRotacao=0 Ângulo de rotação da &lt;em>imagem&lt;/em> quando desenhado no &lt;code>canvas&lt;/code>, usado também em conjunto com a &lt;em>velocidade&lt;/em>, compreendido entre &lt;code>0&lt;/code> e &lt;code>360&lt;/code> &amp;mdash; independentemente do valor atribuído, é sempre usado o &lt;em>resto&lt;/em> da sua divisão por &lt;code>360&lt;/code>. A rotação é feita tendo como referência o centro da &lt;em>imagem&lt;/em>.
 * @property {number} deltaRotacao=0 Variação do ângulo de rotação da &lt;em>imagem&lt;/em>, após cada iteração de desenho.
 * @property {number} anguloGravidade=0 Ângulo cujo co-seno afecta a aplicação do sentido da &lt;em>gravidade&lt;/em> à &lt;em>imagem&lt;/em>, compreendido entre &lt;code>0&lt;/code> e &lt;code>180&lt;/code>. Se o valor indicado estiver fora deste intervalo, será corrigido para &lt;code>0&lt;/code>, se inferior, ou para &lt;code>360&lt;/code>, se superior.
 * @property {number} deltaGravidade=0 Variação do ângulo aplicado à &lt;em>gravidade&lt;/em>, após cada iteração de desenho.
 * @property {number} opacidade=1.0 Valor da opacidade da &lt;em>imagem&lt;/em> &amp;mdash; pode variar entre &lt;code>0.0&lt;/code> (completamente transparente) e &lt;code>1.0&lt;/code> (completamente opaco). Se o valor atribuído estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code>, se inferior, ou para &lt;code>1.0&lt;/code>, se superior.
 * @property {boolean} activo=true Indicação de que a &lt;em>imagem&lt;/em> deve testar colisões, quando chamado o método &lt;code>colide()&lt;/code>. Será útil quando os &lt;em>texto&lt;/em> são processados em bloco, por exemplo, num &lt;em>array&lt;/em>, e nem todos devem ser testados para colisões, ou mesmo para quando há momentos em que a &lt;em>imagem&lt;/em> deve reagir a colisões e noutros não.
 * @property {boolean} visivel=true Indicação de que a &lt;em>imagem&lt;/em> deve ser desenhado no &lt;code>canvas&lt;/code>, quando chamado o método &lt;code>desenha()&lt;/code>.
 * @property {boolean} actualiza=true Indicação de que a &lt;em>imagem&lt;/em> deve ter o seu posicionamento actualizado após o seu &lt;em>desenho&lt;/em> na &lt;em>tela&lt;/em>.
 */
class Imagem extends Grafico {
  #imagem;

  /**
   * Construtor para criação de novos objectos do tipo &lt;code>Imagem&lt;/code>.
   * @param {number} x Abscissa para posicionar a &lt;em>imagem&lt;/em> no &lt;code>canvas&lt;/code>.
   * @param {number} y Ordenada para posicionar a &lt;em>imagem&lt;/em> no &lt;code>canvas&lt;/code>.
   * @param {HTMLImageElement} imagem Elemento HTML que contém a &lt;em>imagem&lt;/em>.
   * @throws {TypeError} Se &lt;code>x&lt;/code> ou &lt;code>y&lt;/code> não forem números finitos.
   * @throws {TypeError} Se &lt;code>imagem&lt;/code> não for um objecto do tipo &lt;code>HTMLImageElement&lt;/code>
   */
  constructor(x, y, imagem, largura, altura) {
    if (typeof x !== 'number' || !Number.isFinite(x)) {
      throw new TypeError('O parâmetro "x" deve ser um número finito.');
    }
    if (typeof y !== 'number' || !Number.isFinite(y)) {
      throw new TypeError('O parâmetro "y" deve ser um número finito.');
    }
    if (!(imagem instanceof HTMLImageElement)) {
      throw new TypeError('O parâmetro "imagem" deve ser um objecto do tipo "HTMLImageElement".');
    }
    super(x, y);
    this.#imagem = imagem;
  }

  set imagem(valor) {
    if (!(valor instanceof HTMLImageElement)) {
      throw new TypeError('O valor "imagem" eve ser um objecto do tipo "HTMLImageElement".');
    }
    this.#imagem = valor;
  }

  get imagem() {
    return this.#imagem;
  }

  /**
   * Largura da &lt;em>imagem&lt;/em>, em &lt;em>pixels&lt;/em>.
   * @type {number}
   * @readonly
   */
  get largura() {
    return this.#imagem.width;
  }

  /**
   * Altura da &lt;em>imagem&lt;/em>, em &lt;em>pixels&lt;/em>.
   * @type {number}
   * @readonly
   */
  get altura() {
    return this.#imagem.height;
  }

  /**
   * Desenha uma &lt;em>imagem&lt;/em> no &lt;code>canvas&lt;/code>, usando como referência de posicionamento o &lt;em>ponto&lt;/em> correspondente ao canto superior esquerdo dessa &lt;em>imagem&lt;/em>. Opcionalmente, também recebe como argumento um &lt;em>delta tempo&lt;/em>, de modo a garantir uma uniformização das animações e dos movimentos entre diferentes dispositivos. Se este argumento for usado, as &lt;em>variações&lt;/em> das coordenadas devem ser expressas em função de um segundo &amp;mdash; i.e., &lt;em>pixels&lt;/em> por segundo; caso contrário, assume-se que a &lt;em>variação&lt;/em> é definida em função de cada iteração &amp;mdash; i.e., &lt;em>pixels&lt;/em> por chamada ao método &lt;code>desenha()&lt;/code>.
   * @param {Tela} tela Objecto que representa o elemento &lt;code>canvas&lt;/code> onde será desenhada a &lt;em>imagem&lt;/em>
   * @param {number} [deltaTempo=1] Variação temporal entre chamadas (para sincronização de animações); se não for fornecido, assume-se o valor &lt;code>1&lt;/code>.
   * @throws {TypeError} Se &lt;code>tela&lt;/code> não for uma instância de &lt;code>Tela&lt;/code>.
   * @throws {TypeError} Se &lt;code>deltaTempo&lt;/code> não for um número finito e positivo.
   * @throws {RangeError} Se o parâmetro &lt;code>deltaTempo&lt;/code> for um número negativo.
   */
  desenha(tela, deltaTempo = 1) {
    if (!(tela instanceof Tela)) {
      throw new TypeError('O parâmetro "tela" deve ser uma instância de "Tela".');
    }
    if (typeof deltaTempo !== 'number' || !Number.isFinite(deltaTempo)) {
      throw new TypeError('O parâmetro "deltaTempo" deve ser um número finito.');
    }
    if (deltaTempo &lt; 0) {
      throw new RangeError('O parâmetro "deltaTempo" não pode ser um número negativo.');
    }
    super.desenha(tela, () => {
      const contexto = tela.contexto;
      contexto.drawImage(this.#imagem, Math.floor(-this.largura * 0.5), Math.floor(-this.altura * 0.5), this.largura, this.altura);
    }, deltaTempo);
  }
}

//

/**
 * @class
 * @extends Grafico
 * @classdesc A classe &lt;code>ImagemAnimada&lt;/code> é uma subclasse de &lt;code>Grafico&lt;/code>, servindo para representar &lt;em>imagens animadas&lt;/em> (ou &lt;em>sprites&lt;/em>). Num nível básico, uma &lt;em>imagem animada&lt;/em> é definida por um &lt;em>ponto&lt;/em>, correspondente, regra geral, ao seu canto superior esquerdo, com os vários fotogramas a serem desenhados nessa posição, assumindo-se dimensões idênticas para cada um deles. Assim, os &lt;em>sprites&lt;/em> utilizados podem ter uma sequência horizontal (tira) ou várias, desde que os fotogramas tenham as mesmas dimensões.
 * @property {number} x Abscissa para posicionar o &lt;em>sprite&lt;/em> no &lt;code>canvas&lt;/code>.
 * @property {number} y Ordenada para posicionar o &lt;em>sprite&lt;/em> no &lt;code>canvas&lt;/code>.
 * @property {HTMLImageElement} imagem Elemento HTML que contém o &lt;em>sprite&lt;/em>
 * @property {number} fotogramas Número de fotogramas (&lt;em>frames&lt;/em>) do &lt;em>sprite&lt;/em>
 * @property {number} iteracoes Número de iterações &amp;mdash; na prática, o número de &lt;em>frames&lt;/em> ou de chamadas ao método &lt;code>desenha()&lt;/code> &amp;mdash; antes de se passar ao fotograma seguinte do &lt;em>sprite&lt;/em>
 * @property {number} animado=true Indicação de que o &lt;em>sprite&lt;/em> deve ser desenhado &lt;em>animado&lt;/em> no &lt;code>canvas&lt;/code>, quando chamado o método &lt;code>desenha()&lt;/code>; caso contrário, ficará parado num dos fotogramas
 * @property {number} fotograma=0 Índice do fotograma a ser mostrado num dado momento; varia, de acordo como o número de &lt;em>iterações&lt;/em> definido, entre zero (&lt;code>0&lt;/code>) e o número de fotogramas existentes (&lt;em>exclusive&lt;/em>)
 * @property {number} tira=0 Índice da tira de fotogramas a ser mostrada num dado momento; varia entre zero (&lt;code>0&lt;/code>) e o número de tiras existentes (&lt;em>exclusive&lt;/em>).
 * @property {number} tiras=1 Número de tiras existentes no &lt;em>spritesheet&lt;/em>.
 * @property {number} deltaX=0 Variação horizontal da posição da &lt;em>imagem animada&lt;/em>, após cada iteração de desenho.
 * @property {number} deltaY=0 Variação vertical da posição da &lt;em>imagem animada&lt;/em>, após cada iteração de desenho.
 * @property {number} distX=0 Distância horizontal da &lt;em>imagem animada&lt;/em> até um dado ponto.
 * @property {number} distY=0 Distância vertical da &lt;em>imagem animada&lt;/em> até um dado ponto.
 * @property {number} gravidade=0 Força que, quando usada em conjunto com um &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação vertical da &lt;em>imagem animada&lt;/em>, actuando como a &lt;em>gravidade&lt;/em>.
 * @property {number} velocidade=0 Velocidade que, quando usada em conjunto com um &lt;em>ângulo (de rotação)&lt;/em>, pode ser utilizada para definir a variação horizontal e vertical da &lt;em>imagem animada&lt;/em>.
 * @property {number} atrito=0.0 Força que reduz o movimento (sejam os &lt;em>deltas&lt;/em> ou a &lt;em>velocidade&lt;/em>) da &lt;em>imagem animada&lt;/em>. O valor deve estar compreendido entre &lt;code>0&lt;/code> (sem atrito) e &lt;code>1&lt;/code> (movimento totalmente travado). Se o valor indicado estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code>, se inferior, ou para &lt;code>1.0&lt;/code>, se superior.
 * @property {number} anguloRotacao=0 Ângulo de rotação da &lt;em>imagem animada&lt;/em> quando desenhado no &lt;code>canvas&lt;/code>, usado também em conjunto com a &lt;em>velocidade&lt;/em>, compreendido entre &lt;code>0&lt;/code> e &lt;code>360&lt;/code> &amp;mdash; independentemente do valor atribuído, é sempre usado o &lt;em>resto&lt;/em> da sua divisão por &lt;code>360&lt;/code>. A rotação é feita tendo como referência o centro da &lt;em>imagem animada&lt;/em>.
 * @property {number} deltaRotacao=0 Variação do ângulo de rotação da &lt;em>imagem animada&lt;/em>, após cada iteração de desenho.
 * @property {number} anguloGravidade=0 Ângulo cujo co-seno afecta a aplicação do sentido da &lt;em>gravidade&lt;/em> à &lt;em>imagem animada&lt;/em>, compreendido entre &lt;code>0&lt;/code> e &lt;code>180&lt;/code>. Se o valor indicado estiver fora deste intervalo, será corrigido para &lt;code>0&lt;/code>, se inferior, ou para &lt;code>360&lt;/code>, se superior.
 * @property {number} deltaGravidade=0 Variação do ângulo aplicado à &lt;em>gravidade&lt;/em>, após cada iteração de desenho.
 * @property {number} opacidade=1.0 Valor da opacidade da &lt;em>imagem animada&lt;/em> &amp;mdash; pode variar entre &lt;code>0.0&lt;/code> (completamente transparente) e &lt;code>1.0&lt;/code> (completamente opaco). Se o valor atribuído estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code>, se inferior, ou para &lt;code>1.0&lt;/code>, se superior.
 * @property {boolean} activo=true Indicação de que a &lt;em>imagem animada&lt;/em> deve testar colisões, quando chamado o método &lt;code>colide()&lt;/code>. Será útil quando os &lt;em>texto&lt;/em> são processados em bloco, por exemplo, num &lt;em>array&lt;/em>, e nem todos devem ser testados para colisões, ou mesmo para quando há momentos em que a &lt;em>imagem animada&lt;/em> deve reagir a colisões e noutros não.
 * @property {boolean} visivel=true Indicação de que a &lt;em>imagem animada&lt;/em> deve ser desenhado no &lt;code>canvas&lt;/code>, quando chamado o método &lt;code>desenha()&lt;/code>.
 * @property {boolean} actualiza=true Indicação de que a &lt;em>imagem animada&lt;/em> deve ter o seu posicionamento actualizado após o seu &lt;em>desenho&lt;/em> na &lt;em>tela&lt;/em>.
 */
class ImagemAnimada extends Grafico {
  #tempoAcumulado;
  #fotogramas;
  #fotograma;
  #animado;
  #imagem;
  #tiras;
  #tira;
  #fps;

  /**
   * Construtor para criação de novos objectos do tipo &lt;code>ImagemAnimada&lt;/code>
   * @param {number} x Abscissa para posicionar o &lt;em>sprite&lt;/em> no &lt;code>canvas&lt;/code>
   * @param {number} y Ordenada para posicionar o &lt;em>sprite&lt;/em> no &lt;code>canvas&lt;/code>
   * @param {HTMLImageElement} imagem Elemento HTML que contém o &lt;em>spritesheet&lt;/em>
   * @param {number} fotogramas Número de fotogramas (&lt;em>frames&lt;/em>) do &lt;em>sprite&lt;/em>
   * @param {number} fotograma Fotograma (&lt;em>frame&lt;/em>) actual do &lt;em>sprite&lt;/em>
   * @param {number} fps Número de fotogramas por segundo (fps), para definir a transição entre os fotogramas do &lt;em>sprite&lt;/em>.
   * @param {number} [tiras=1] Número de tiras existentes no &lt;em>spritesheet&lt;/em>.
   * @param {number} tira Tira actual do &lt;em>spritesheet&lt;/em>.
   * @param {boolean} animado Indicação de que o &lt;em>sprite&lt;/em> se deve encontrar em movimento.
   * @throws {TypeError} Se o parâmetro x não for um número finito.
   * @throws {TypeError} Se o parâmetro y não for um número finito.
   * @throws {TypeError} Se o parâmetro imagem não for um objeto do tipo &lt;code>HTMLImageElement&lt;/code>.
   * @throws {TypeError} Se o parâmetro fotogramas não for um número finito.
   * @throws {RangeError} Se o parâmetro fotogramas} não for um número positivo.
   * @throws {TypeError} Se o parâmetro fps não for um número finito.
   * @throws {RangeError} Se o parâmetro fps não for um número positivo.
   * @throws {TypeError} Se o parâmetro tiras não for um número finito.
   * @throws {RangeError} Se o parâmetro tiras não for um número positivo.
   */
  constructor(x, y, imagem, fotogramas, fps, tiras = 1) {
    if (typeof x !== 'number' || !Number.isFinite(x)) {
      throw new TypeError('O parâmetro "x" deve ser um número finito.');
    }
    if (typeof y !== 'number' || !Number.isFinite(y)) {
      throw new TypeError('O parâmetro "y" deve ser um número finito.');
    }
    if (!(typeof imagem === 'object' &amp;&amp; imagem instanceof HTMLImageElement)) {
      throw new TypeError('O parâmetro "imagem" deve ser um objecto do tipo "HTMLImageElement".');
    }
    if (typeof fotogramas !== 'number' || !Number.isFinite(fotogramas)) {
      throw new TypeError('O parâmetro "fotogramas" deve ser um número finito.');
    }
    if (fotogramas &lt;= 0) {
      throw new RangeError('O parâmetro "fotogramas" deve ser um número positivo.');
    }
    if (typeof fps !== 'number' || !Number.isFinite(fps)) {
      throw new TypeError('O parâmetro "fps" deve ser um número finito.');
    }
    if (fps &lt;= 0) {
      throw new RangeError('O parâmetro "fps" deve ser um número positivo.');
    }
    if (typeof tiras !== 'number' || !Number.isFinite(tiras)) {
      throw new TypeError('O parâmetro "tiras" deve ser um número finito.');
    }
    if (tiras &lt;= 0) {
      throw new RangeError('O parâmetro "tiras" deve ser um número positivo.');
    }
    super(x, y);
    this.#imagem = imagem;
    this.#fotogramas = fotogramas;
    this.#fps = fps;
    this.#tiras = tiras;
    this.#fotograma = 0;
    this.#tira = 0;
    this.#animado = true;
    this.#tempoAcumulado = 0;
  }

  set imagem(valor) {
    if (valor == null || !(valor instanceof HTMLImageElement)) {
      throw new TypeError('O valor "imagem" deve ser um objecto do tipo "HTMLImageElement".');
    }
    this.#imagem = valor;
  }

  get imagem() {
    return this.#imagem;
  }

  set animado(valor) {
    if (typeof valor !== 'boolean') {
      throw new TypeError('O valor de "animado" deve ser booleano ("true" ou "false").');
    }
    this.#animado = valor;
  }

  get animado() {
    return this.#animado;
  }

  set fotogramas(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "fotogramas" deve ser um número finito.');
    }
    if (valor &lt;= 0) {
      throw new RangeError('O valor de "fotogramas" deve ser um número positivo.');
    }
    this.#fotogramas = valor;
  }

  get fotogramas() {
    return this.#fotogramas;
  }

  set fps(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "fps" deve ser um número finito.');
    }
    if (valor &lt;= 0) {
      throw new RangeError('O valor de "fps" deve ser um número positivo.');
    }
    this.#fps = valor;
  }

  get fps() {
    return this.#fps;
  }

  set tiras(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "tiras" deve ser um número finito.');
    }
    if (valor &lt;= 0) {
      throw new RangeError('O valor de "tiras" deve ser um número positivo.');
    }
    this.#tiras = valor;
  }
  get tiras() {
    return this.#tiras;
  }

  set fotograma(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "fotograma" deve ser um número finito.');
    }
    if (valor &lt; 0 || valor >= this.fotogramas) {
      throw new RangeError('O valor de "fotograma" deve ser um número entre 0 e fotogramas-1.');
    }
    this.#fotograma = valor;
  }

  get fotograma() {
    return this.#fotograma;
  }

  set tira(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "tira" deve ser um número positivo.');
    }
    if (valor &lt; 0 || valor >= this.tiras) {
      throw new RangeError('O valor de "tira" deve ser um número entre 0 e tiras-1.');
    }
    this.#tira = valor;
  }

  get tira() {
    return this.#tira;
  }

  /**
   * Altura da &lt;em>imagem animada&lt;/em>, considerando o número de tiras presentes e assumindo dimensões idênticas das mesmas
   * @type {number}
   * @readonly
   */
  get largura() {
    return this.#imagem.width / this.#fotogramas;
  }

  /**
   * Largura da &lt;em>imagem animada&lt;/em>, considerando o número de fotogramas presentes e assumindo dimensões idênticas dos mesmos
   * @type {number}
   * @readonly
   */
  get altura() {
    return this.#imagem.height / this.#tiras;
  }

  /**
   * Desenha uma &lt;em>imagem animada&lt;/em> no &lt;code>canvas&lt;/code>, usando como referência de posicionamento o &lt;em>ponto&lt;/em> correspondente ao canto superior esquerdo dessa &lt;em>imagem animada&lt;/em>, no caso de uma única tira. Havendo mais que uma tira, usará o &lt;em>ponto&lt;/em> correspondente ao canto superior esquerdo dessa tira. Opcionalmente, também recebe como argumento um &lt;em>delta tempo&lt;/em>, de modo a garantir uma uniformização das animações e dos movimentos entre diferentes dispositivos. Se este argumento for usado, as &lt;em>variações&lt;/em> das coordenadas devem ser expressas em função de um segundo &amp;mdash; i.e., &lt;em>pixels&lt;/em> por segundo; caso contrário, assume-se que a &lt;em>variação&lt;/em> é definida em função de cada iteração &amp;mdash; i.e., &lt;em>pixels&lt;/em> por chamada ao método &lt;code>desenha()&lt;/code>.
   * @param {Tela} tela Objecto que representa o elemento &lt;code>canvas&lt;/code> onde será desenhada a &lt;em>imagem animada&lt;/em>
   * @param {number} [deltaTempo=1] Variação temporal entre chamadas (para sincronização de animações); se não for fornecido, assume-se o valor &lt;code>1&lt;/code>.
   * @throws {TypeError} Se &lt;code>tela&lt;/code> não for uma instância de &lt;code>Tela&lt;/code>.
   * @throws {TypeError} Se &lt;code>deltaTempo&lt;/code> não for um número finito e positivo.
   * @throws {RangeError} Se o parâmetro &lt;code>deltaTempo&lt;/code> for um número negativo.
   */
  desenha(tela, deltaTempo = 1) {
    if (!(tela instanceof Tela)) {
      throw new TypeError('O parâmetro "tela" deve ser uma instância de "Tela".');
    }
    if (typeof deltaTempo !== 'number' || !Number.isFinite(deltaTempo)) {
      throw new TypeError('O parâmetro "deltaTempo" deve ser um número finito.');
    }
    if (deltaTempo &lt; 0) {
      throw new RangeError('O parâmetro "deltaTempo" não pode ser um número negativo.');
    }
    super.desenha(tela, () => {
      const contexto = tela.contexto;
      const intervaloTempo = 1 / this.#fps;
      const maxAvancos = this.#fotogramas - this.#fotograma;
      contexto.drawImage(this.#imagem, this.#fotograma * this.largura, this.#tira * this.altura, this.largura, this.altura, Math.floor(-this.largura * 0.5), Math.floor(-this.altura * 0.5), this.largura, this.altura);
      if ((this.#animado) || (this.#fotograma > 0)) {
        this.#tempoAcumulado += deltaTempo;
        let avancos = 0;
        if (this.#tempoAcumulado >= intervaloTempo) {
          this.#fotograma++;
          if (this.#fotograma >= this.fotogramas) {
            this.#fotograma = 0;
          }
          this.#tempoAcumulado -= intervaloTempo;
          avancos++;
        }
        if (avancos >= maxAvancos) {
          this.#tempoAcumulado = 0;
        }
      }
    }, deltaTempo);
  }
}

//

/**
 * @class
 * @extends Grafico
 * @classdesc A classe &lt;code>ImagemFilme&lt;/code> é uma subclasse de &lt;code>Grafico&lt;/code>, servindo para representar &lt;em>filmes&lt;/em> (&lt;em>vídeos&lt;/em>) de forma embutida no &lt;code>canvas&lt;/code>. Num nível básico, uma &lt;em>imagem de filme&lt;/em> é definida por um &lt;em>ponto&lt;/em>, correspondente, regra geral, ao seu canto superior esquerdo e pela própria imagem &amp;mdash; i.e., o filme.
 * @property {number} x Abscissa para posicionar o &lt;em>filme&lt;/em> no &lt;code>canvas&lt;/code>.
 * @property {number} y Ordenada para posicionar o &lt;em>filme&lt;/em> no &lt;code>canvas&lt;/code>.
 * @property {HTMLVideoElement} filme Objecto de &lt;em>vídeo&lt;/em> a ser desenhado no &lt;code>canvas&lt;/code>
 * @property {number} deltaX=0 Variação horizontal da posição do &lt;em>filme&lt;/em>, após cada iteração de desenho.
 * @property {number} deltaY=0 Variação vertical da posição do &lt;em>filme&lt;/em>, após cada iteração de desenho.
 * @property {number} distX=0 Distância horizontal do &lt;em>filme&lt;/em> até um dado ponto.
 * @property {number} distY=0 Distância vertical do &lt;em>filme&lt;/em> até um dado ponto.
 * @property {number} gravidade=0 Força que, quando usada em conjunto com um &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação vertical do &lt;em>filme&lt;/em>, actuando como a &lt;em>gravidade&lt;/em>.
 * @property {number} velocidade=0 Velocidade que, quando usada em conjunto com um &lt;em>ângulo (de rotação)&lt;/em>, pode ser utilizada para definir a variação horizontal e vertical do &lt;em>filme&lt;/em>.
 * @property {number} atrito=0.0 Força que reduz o movimento (sejam os &lt;em>deltas&lt;/em> ou a &lt;em>velocidade&lt;/em>) do &lt;em>filme&lt;/em>. O valor deve estar compreendido entre &lt;code>0&lt;/code> (sem atrito) e &lt;code>1&lt;/code> (movimento totalmente travado). Se o valor indicado estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code>, se inferior, ou para &lt;code>1.0&lt;/code>, se superior.
 * @property {number} anguloRotacao=0 Ângulo de rotação do &lt;em>filme&lt;/em> quando desenhado no &lt;code>canvas&lt;/code>, usado também em conjunto com a &lt;em>velocidade&lt;/em>, compreendido entre &lt;code>0&lt;/code> e &lt;code>360&lt;/code> &amp;mdash; independentemente do valor atribuído, é sempre usado o &lt;em>resto&lt;/em> da sua divisão por &lt;code>360&lt;/code>. A rotação é feita tendo como referência o centro do &lt;em>filme&lt;/em>.
 * @property {number} deltaRotacao=0 Variação do ângulo de rotação do &lt;em>filme&lt;/em>, após cada iteração de desenho.
 * @property {number} anguloGravidade=0 Ângulo cujo co-seno afecta a aplicação do sentido da &lt;em>gravidade&lt;/em> ao &lt;em>filme&lt;/em>, compreendido entre &lt;code>0&lt;/code> e &lt;code>180&lt;/code>. Se o valor indicado estiver fora deste intervalo, será corrigido para &lt;code>0&lt;/code>, se inferior, ou para &lt;code>360&lt;/code>, se superior.
 * @property {number} deltaGravidade=0 Variação do ângulo aplicado à &lt;em>gravidade&lt;/em>, após cada iteração de desenho.
 * @property {number} opacidade=1.0 Valor da opacidade do &lt;em>filme&lt;/em> &amp;mdash; pode variar entre &lt;code>0.0&lt;/code> (completamente transparente) e &lt;code>1.0&lt;/code> (completamente opaco). Se o valor atribuído estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code>, se inferior, ou para &lt;code>1.0&lt;/code>, se superior.
 * @property {boolean} activo=true Indicação de que o &lt;em>filme&lt;/em> deve testar colisões, quando chamado o método &lt;code>colide()&lt;/code>. Será útil quando os &lt;em>filme&lt;/em> são processados em bloco, por exemplo, num &lt;em>array&lt;/em>, e nem todos devem ser testados para colisões, ou mesmo para quando há momentos em que o &lt;em>filme&lt;/em> deve reagir a colisões e noutros não.
 * @property {boolean} visivel=true Indicação de que o &lt;em>filme&lt;/em> deve ser desenhado no &lt;code>canvas&lt;/code>, quando chamado o método &lt;code>desenha()&lt;/code>.
 * @property {boolean} actualiza=true Indicação de que o &lt;em>filme&lt;/em> deve ter o seu posicionamento actualizado após o seu &lt;em>desenho&lt;/em> na &lt;em>tela&lt;/em>.
 */
class ImagemFilme extends Grafico {
  #filme;

  /**
   * Construtor para criação de novos objectos do tipo &lt;code>ImagemFilme&lt;/code>
   * @param {number} x Abscissa para posicionar o &lt;em>filme&lt;/em> no &lt;code>canvas&lt;/code>
   * @param {number} y Ordenada para posicionar o &lt;em>filme&lt;/em> no &lt;code>canvas&lt;/code>
   * @param {Filme} filme Objecto de &lt;em>vídeo&lt;/em> a ser desenhado no &lt;code>canvas&lt;/code>
   * @throws {TypeError} Se &lt;code>filme&lt;/code> não for uma instância de &lt;code>Filme&lt;/code>.
   */
  constructor(x, y, filme) {
    super(x, y);
    if (!(filme instanceof Filme)) {
      throw new TypeError('O argumento "filme" deve ser uma instância de "Filme".');
    }
    this.#filme = filme;
  }

  set filme(valor) {
    if (!(valor instanceof Filme)) {
      throw new TypeError('O valor de "filme" deve ser uma instância de "Filme".');
    }
    this.#filme = novoFilme;
  }

  get filme() {
    return this.#filme;
  }

  /**
   * Largura do &lt;em>filme&lt;/em> (&lt;em>vídeo&lt;/em>).
   * @type {number}
   */
  get largura() {
    return this.#filme.largura;
  }

  /**
   * Altura do &lt;em>filme&lt;/em> (&lt;em>vídeo&lt;/em>).
   * @type {number}
   */
  get altura() {
    return this.#filme.altura;
  }

  /**
   * Verifica se um dado &lt;em>ponto&lt;/em> está contido área do &lt;em>invólucro&lt;/em> rectangular que envolve este &lt;em>gráfico&lt;/em>. Tal acontece quando esse &lt;em>ponto&lt;/em> está compreendido entre &lt;em>x&lt;/em> e &lt;em>x mais a largura&lt;/em> e entre &lt;em>y&lt;/em> e &lt;em>y mais altura&lt;/em> desse &lt;em>invólucro&lt;/em>.
   * @param {number} x Abscissa do ponto a testar se está contido neste &lt;em>gráfico&lt;/em>
   * @param {number} y Ordenada do ponto a testar se está contido neste &lt;em>gráfico&lt;/em>
   * @returns {boolean} Se o ponto estiver contido neste &lt;em>gráfico&lt;/em>, &lt;code>true&lt;/code>; senão, &lt;code>false&lt;/code>
   * @throws {TypeError} Se &lt;code>x&lt;/code> ou &lt;code>y&lt;/code> não forem números finitos.
   */
  contemPonto(x, y) {
    if (typeof x !== 'number' || !Number.isFinite(x)) {
      throw new TypeError('O parâmetro "x" deve ser um número finito.');
    }
    if (typeof y !== 'number' || !Number.isFinite(y)) {
      throw new TypeError('O parâmetro "y" deve ser um número finito.');
    }
    if (this.anguloRotacao !== 0) {
      return super.contemPonto(x, y);
    }
    else {
      return (x > this.x &amp;&amp; x &lt;= this.x + this.largura &amp;&amp; y > this.y &amp;&amp; y &lt;= this.y + this.altura);
    }
  }

  /**
   * Desenha um &lt;code>video&lt;/code> no &lt;code>canvas&lt;/code>, usando como referência de posicionamento o &lt;em>ponto&lt;/em> correspondente ao canto superior esquerdo desse &lt;em>vídeo&lt;/em>. Note-se que o &lt;em>vídeo&lt;/em> só é efetivamente reproduzido no &lt;code>canvas&lt;/code> se o elemento &lt;code>video&lt;/code> associado por via da propriedade &lt;code>filme&lt;/code> estiver também a ser reproduzido. Opcionalmente, também recebe como argumento um &lt;em>delta tempo&lt;/em>, de modo a garantir uma uniformização das animações e dos movimentos entre diferentes dispositivos. Se este argumento for usado, as &lt;em>variações&lt;/em> das coordenadas devem ser expressas em função de um segundo &amp;mdash; i.e., &lt;em>pixels&lt;/em> por segundo; caso contrário, assume-se que a &lt;em>variação&lt;/em> é definida em função de cada iteração &amp;mdash; i.e., &lt;em>pixels&lt;/em> por chamada ao método &lt;code>desenha()&lt;/code>.
   * @param {Tela} tela Objecto que representa o elemento &lt;code>canvas&lt;/code> onde será desenhado o &lt;em>vídeo&lt;/em>
   * @param {number} [deltaTempo=1] Variação temporal entre chamadas (para sincronização de animações); se não for fornecido, assume-se o valor &lt;code>1&lt;/code>.
   * @throws {TypeError} Se &lt;code>tela&lt;/code> não for uma instância de &lt;code>Tela&lt;/code>.
   * @throws {TypeError} Se &lt;code>deltaTempo&lt;/code> não for um número finito.
   * @throws {RangeError} Se o parâmetro &lt;code>deltaTempo&lt;/code> for um número negativo.
   */
  desenha(tela, deltaTempo = 1) {
    if (!(tela instanceof Tela)) {
      throw new TypeError('O parâmetro "tela" deve ser uma instância de "Tela".');
    }
    if (typeof deltaTempo !== 'number' || !Number.isFinite(deltaTempo)) {
      throw new TypeError('O parâmetro "deltaTempo" deve ser um número finito.');
    }
    if (deltaTempo &lt; 0) {
      throw new RangeError('O parâmetro "deltaTempo" não pode ser um número negativo.');
    }
    super.desenha(tela, () => {
      const contexto = tela.contexto;
      contexto.drawImage(this.#filme.media, Math.floor(-this.largura * 0.5), Math.floor(-this.altura * 0.5));
    }, deltaTempo);
  }
}

//

/**
 * @class
 * @classdesc A classe &lt;code>Padrao&lt;/code> é utilizada para representar a criação de &lt;em>padrões&lt;/em> gráficos, que podem ser posteriormente aplicados como preenchimento ou contorno de &lt;em>gráficos&lt;/em> em elementos &lt;code>canvas&lt;/code>.
 * @property {HTMLImageElement} imagem Elemento HTML que contém a &lt;em>imagem&lt;/em> utilizada no &lt;em>padrão&lt;/em>, ou &lt;code>null&lt;/code> se o padrão foi criado directamente a partir de um &lt;code>CanvasPattern&lt;/code>.
 * @property {CanvasPattern} padrao O &lt;em>padrão&lt;/em> propriamente dito, pronto a ser utilizado para preenchimento e contorno.
 * @property {string} repeticao Tipo de repetição a aplicar na criação do &lt;em>padrão&lt;/em> (&lt;code>repeat&lt;/code> | &lt;code>repeat-x&lt;/code> | &lt;code>repeat-y&lt;/code> | &lt;code>no-repeat&lt;/code>).
 */
class PadraoImagem {
  #repeticao;
  #imagem;
  #padrao;

  /**
   * Construtor para criação de novos objectos do tipo &lt;code>Padrao&lt;/code> com base em imagens e um tipo de repetição especificado.
   * @param {HTMLImageElement} imagem Elemento de imagem (&lt;code>HTMLImageElement&lt;/code>) a usar no &lt;em>padrão&lt;/em>.
   * @param {string} [repeticao='repeat'] Tipo de repetição a aplicar na criação do &lt;em>padrão&lt;/em> (&lt;code>repeat&lt;/code> | &lt;code>repeat-x&lt;/code> | &lt;code>repeat-y&lt;/code> | &lt;code>no-repeat&lt;/code>).
   * @throws {TypeError} Se a imagem for nula, não estiver definida ou não for do tipo correcto.
   * @throws {TypeError} Se o tipo de repetição indicado não for válido.
   */
  constructor(imagem, repeticao = 'repeat') {
    if (!(imagem instanceof HTMLImageElement)) {
      throw new TypeError('O parâmetro "imagem" deve ser um objecto do tipo "HTMLImageElement".');
    }
    if (!PadraoImagem.REPETICOES.includes(repeticao)) {
      throw new TypeError('O parâmetro "repeticao" não tem um valor válido.');
    }
    this.#repeticao = repeticao;
    this.#imagem = imagem;
    const tela = document.createElement('canvas');
    const contexto = tela.getContext('2d');
    this.#padrao = contexto.createPattern(this.#imagem, this.#repeticao);
  }

  set imagem(valor) {
    if (!(valor instanceof HTMLImageElement)) {
      throw new TypeError('O valor de "imagem" não é um elemento do tipo "HTMLImageElement".');
    }
    this.#imagem = valor;
    let tela = document.createElement('canvas');
    let contexto = tela.getContext('2d');
    this.#padrao = contexto.createPattern(this.#imagem, this.#repeticao);
  }

  get imagem() {
    return this.#imagem;
  }

  set repeticao(valor) {
    if (!PadraoImagem.REPETICOES.includes(valor)) {
      throw new TypeError('O valor de "repeticao" não é válido.');
    }
    this.#repeticao = valor;
    let tela = document.createElement('canvas');
    let contexto = tela.getContext('2d');
    this.#padrao = contexto.createPattern(this.#imagem, this.#repeticao);
  }

  get repeticao() {
    return this.#repeticao;
  }

  /**
   * O &lt;em>padrão&lt;/em> propriamente dito, a ser utilizado para preenchimento e contorno de &lt;em>gráficos&lt;/em>.
   * @type {CanvasPattern}
   * @readonly
   */
  get padrao() {
    return this.#padrao;
  }

  /**
   * Lista dos modos de repetição válidos para padrões de preenchimento ou contorno de &lt;em>gráficos&lt;/em> no &lt;em>canvas&lt;/em>.
   * @type {string[]}
   * @static
   * @const
   */
  static REPETICOES = ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'];
}

//

/**
 * @class
 * @classdesc A classe &lt;code>Tela&lt;/code> serve essencialmente como um &lt;em>invólucro&lt;/em> para elementos do tipo &lt;code>canvas&lt;/code>. Permite gerir facilmente o desenho, a ordem e a interacção de &lt;em>gráficos&lt;/em> sobre o &lt;em>canvas&lt;/em>, bem como o tratamento de eventos de rato e teclado.
 * @property {HTMLCanvasElement} canvas O &lt;em>elemento&lt;/em> HTML do tipo &lt;code>canvas&lt;/code> a ser representado.
 * @property {CanvasRenderingContext2D} contexto O contexto &lt;strong>2D&lt;/strong> do &lt;em>canvas&lt;/em> associado.
 * @property {number} largura A largura actual da &lt;em>tela&lt;/em> (em &lt;em>pixels&lt;/em>).
 * @property {number} altura A altura actual da &lt;em>tela&lt;/em> (em &lt;em>pixels&lt;/em>).
 * @property {number} ratoX Coordenada &lt;em>x&lt;/em> actual do rato na &lt;em>tela&lt;/em>.
 * @property {number} ratoY Coordenada &lt;em>y&lt;/em> actual do rato na &lt;em>tela&lt;/em>.
 * @property {string|undefined} tecla Código da tecla actualmente pressionada, se existir.
 * @property {string} cursor Tipo de cursor actualmente definido para o &lt;em>canvas&lt;/em> (e.g.: &lt;code>pointer&lt;/code>, &lt;code>crosshair&lt;/code>, &lt;code>default&lt;/code>, etc.).
 */
class Tela {
  #ratoX;
  #ratoY;
  #tecla;
  #canvas;
  #contexto;
  #graficos;
  #tempoAnterior;

  /**
   * Construtor para criação de novos objectos do tipo &lt;code>Tela&lt;/code>. Inicializa uma nova instância associada a um elemento HTML do tipo &lt;code>canvas&lt;/code>, preparando todos os campos internos necessários ao funcionamento da &lt;em>tela&lt;/em> e associando os &lt;em>eventos&lt;/em> de rato e teclado relevantes.
   * @param {HTMLCanvasElement} canvas O &lt;em>elemento&lt;/em> do tipo &lt;code>HTMLCanvasElement&lt;/code> a ser representado.
   * @throws {TypeError} Se o parâmetro &lt;code>canvas&lt;/code> for nulo, não estiver definido ou não for um elemento &lt;code>canvas&lt;/code> válido.
   */
  constructor(canvas) {
    if (!(canvas instanceof HTMLCanvasElement)) {
      throw new TypeError('O parâmetro "canvas" deve ser um objecto do tipo "HTMLCanvasElement".');
    }
    this.#canvas = canvas;
    this.#ratoX = 0;
    this.#ratoY = 0;
    this.#graficos = new Array();
    this.#tecla = undefined;
    this.#tempoAnterior = undefined;
    this.#contexto = this.#canvas.getContext('2d');
    const tiposEventosRato = ['click', 'dblclick', 'contextmenu', 'mousedown', 'mousemove', 'mouseup', 'mouseenter', 'mouseleave'];
    for (const tipoEventoRato of tiposEventosRato) {
      this.#canvas.addEventListener(tipoEventoRato, (evento) => this.#processaRato(evento));
    }
    const tiposEventosTeclado = ['keydown', 'keyup'];
    for (const tipoEventoTeclado of tiposEventosTeclado) {
      window.addEventListener(tipoEventoTeclado, (evento) => this.#processaTeclado(evento));
    }
  }

  #processaRato(evento) {
    this.ratoX = evento.offsetX;
    this.ratoY = evento.offsetY;
    switch (evento.type) {
      case 'click':
        this.processaClique(evento);
        break;
      case 'dblclick':
        this.processaDuploClique(evento);
        break;
      case 'contextmenu':
        this.processaMenuContexto(evento);
        break;
      case 'mousedown':
        this.processaRatoDescido(evento);
        break;
      case 'mousemove':
        this.processaRatoMovido(evento);
        break;
      case 'mouseup':
        this.processaRatoSubido(evento);
        break;
      case 'mouseenter':
        this.processaRatoDentro(evento);
        break;
      case 'mouseleave':
        this.processaRatoFora(evento);
        break;
      default:
        break;
    }
  }

  #processaTeclado(evento) {
    this.#tecla = evento.code;
    switch (evento.type) {
      case 'keydown':
        this.processaTeclaDescida(evento);
        break;
      case 'keyup':
        this.processaTeclaSubida(evento);
        break;
      default:
        break;
    }
    this.#tecla = undefined;
  }

  /**
   * Método chamado quando ocorre o &lt;em>evento&lt;/em> &lt;code>click&lt;/code>, que deverá ser posteriormente definido como uma &lt;em>função&lt;/em> contendo as instruções a executar decorrentes desse evento, podendo, se necessário, utilizar as propriedades &lt;code>ratoX&lt;/code> e &lt;code>ratoY&lt;/code>, associadas às coordenadas do &lt;em>rato&lt;/em> na &lt;em>tela&lt;/em>, já previamente obtidas e prontas a ser usadas.
   * @param {MouseEvent} evento Objecto correspondente ao evento &lt;code>click&lt;/code>.
   */
  processaClique(evento) { }

  /**
   * Método chamado quando ocorre o &lt;em>evento&lt;/em> &lt;code>dblclick&lt;/code>, que deverá ser posteriormente definido como uma &lt;em>função&lt;/em> contendo as instruções a executar decorrentes desse evento, podendo, se necessário, utilizar as propriedades &lt;code>ratoX&lt;/code> e &lt;code>ratoY&lt;/code>, associadas às coordenadas do &lt;em>rato&lt;/em> na &lt;em>tela&lt;/em>, já previamente obtidas e prontas a ser usadas.
   * @param {MouseEvent} evento Objecto correspondente ao evento &lt;code>dblclick&lt;/code>.
   */
  processaDuploClique(evento) { }

  /**
   * Método chamado quando ocorre o &lt;em>evento&lt;/em> &lt;code>contextmenu&lt;/code>, que deverá ser posteriormente definido como uma &lt;em>função&lt;/em> contendo as instruções a executar decorrentes desse evento, podendo, se necessário, utilizar as propriedades &lt;code>ratoX&lt;/code> e &lt;code>ratoY&lt;/code>, associadas às coordenadas do &lt;em>rato&lt;/em> na &lt;em>tela&lt;/em>, já previamente obtidas e prontas a ser usadas.
   * @param {MouseEvent} evento Objecto correspondente ao evento &lt;code>contextmenu&lt;/code>.
   */
  processaMenuContexto(evento) { }

  /**
   * Método chamado quando ocorre o &lt;em>evento&lt;/em> &lt;code>mousedown&lt;/code>, a ser posteriormente definido como uma &lt;em>função&lt;/em> contendo as instruções a executar decorrentes desse evento, utilizando, se necessário, as propriedades &lt;code>ratoX&lt;/code> e &lt;code>ratoY&lt;/code>, associadas às coordenadas do &lt;em>rato&lt;/em> na &lt;em>tela&lt;/em>, já previamente obtidas e prontas a ser usadas
   * @param {MouseEvent} evento Objecto correspondente ao evento &lt;code>mousedown&lt;/code>.
   */
  processaRatoDescido(evento) { }

  /**
   * Método chamado quando ocorre o &lt;em>evento&lt;/em> &lt;code>mousemove&lt;/code>, que deverá ser posteriormente definido como uma &lt;em>função&lt;/em> contendo as instruções a executar decorrentes desse evento, podendo, se necessário, utilizar as propriedades &lt;code>ratoX&lt;/code> e &lt;code>ratoY&lt;/code>, associadas às coordenadas do &lt;em>rato&lt;/em> na &lt;em>tela&lt;/em>, já previamente obtidas e prontas a ser usadas.
   * @param {MouseEvent} evento Objecto correspondente ao evento &lt;code>mousemove&lt;/code>.
   */
  processaRatoMovido(evento) { }

  /**
   * Método chamado quando ocorre o &lt;em>evento&lt;/em> &lt;code>mouseup&lt;/code>, que deverá ser posteriormente definido como uma &lt;em>função&lt;/em> contendo as instruções a executar decorrentes desse evento, podendo, se necessário, utilizar as propriedades &lt;code>ratoX&lt;/code> e &lt;code>ratoY&lt;/code>, associadas às coordenadas do &lt;em>rato&lt;/em> na &lt;em>tela&lt;/em>, já previamente obtidas e prontas a ser usadas.
   * @param {MouseEvent} evento Objecto correspondente ao evento &lt;code>mouseup&lt;/code>.
   */
  processaRatoSubido(evento) { }

  /**
   * Método chamado quando ocorre o &lt;em>evento&lt;/em> &lt;code>mouseenter&lt;/code>, que deverá ser posteriormente definido como uma &lt;em>função&lt;/em> contendo as instruções a executar decorrentes desse evento, podendo, se necessário, utilizar as propriedades &lt;code>ratoX&lt;/code> e &lt;code>ratoY&lt;/code>, associadas às coordenadas do &lt;em>rato&lt;/em> na &lt;em>tela&lt;/em>, já previamente obtidas e prontas a ser usadas.
   * @param {MouseEvent} evento Objecto correspondente ao evento &lt;code>mouseenter&lt;/code>.
   */
  processaRatoDentro(evento) { }

  /**
   * Método chamado quando ocorre o &lt;em>evento&lt;/em> &lt;code>mouseleave&lt;/code>, que deverá ser posteriormente definido como uma &lt;em>função&lt;/em> contendo as instruções a executar decorrentes desse evento, podendo, se necessário, utilizar as propriedades &lt;code>ratoX&lt;/code> e &lt;code>ratoY&lt;/code>, associadas às coordenadas do &lt;em>rato&lt;/em> na &lt;em>tela&lt;/em>, já previamente obtidas e prontas a ser usadas.
   * @param {MouseEvent} evento Objecto correspondente ao evento &lt;code>mouseleave&lt;/code>.
   */
  processaRatoFora(evento) { }

  /**
   * Método chamado quando ocorre o &lt;em>evento&lt;/em> &lt;code>keydown&lt;/code>, que deverá ser posteriormente definido como uma &lt;em>função&lt;/em> contendo as instruções a executar decorrentes desse evento, podendo, se necessário, utilizar a propriedade &lt;code>codigoTecla&lt;/code>, associada à &lt;em>tecla&lt;/em> seleccionada, já previamente obtida e pronta a ser usada.
   * @param {KeyboardEvent} evento Objecto correspondente ao evento &lt;code>keydown&lt;/code>.
   */
  processaTeclaDescida(evento) { }

  /**
   * Método chamado quando ocorre o &lt;em>evento&lt;/em> &lt;code>keyup&lt;/code>, que deverá ser posteriormente definido como uma &lt;em>função&lt;/em> contendo as instruções a executar decorrentes desse evento, podendo, se necessário, utilizar a propriedade &lt;code>codigoTecla&lt;/code>, associada à &lt;em>tecla&lt;/em> seleccionada, já previamente obtida e pronta a ser usada.
   * @param {KeyboardEvent} evento Objecto correspondente ao evento &lt;code>keyup&lt;/code>.
   */
  processaTeclaSubida(evento) { }

  set canvas(valor) {
    if (!(valor instanceof HTMLCanvasElement)) {
      throw new TypeError('O valor de "canvas" deve ser um objecto do tipo "HTMLCanvasElement".');
    }
    this.#canvas = valor;
    this.#contexto = this.#canvas.getContext('2d');
  }

  get canvas() {
    return this.#canvas;
  }

  set cursor(valor) {
    if (!Tela.CURSORES.includes(valor)) {
      throw new TypeError('O valor de "cursor" não é válido.');
    }
    this.#canvas.style.cursor = valor;
  }

  get cursor() {
    return this.#canvas.style.cursor;
  }

  set largura(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "largura" deve ser um número finito.');
    }
    if (valor &lt; 0) {
      throw new TypeError('O valor de "largura" deve ser um número não negativo.');
    }
    this.#canvas.width = valor;
  }

  get largura() {
    return this.#canvas.width;
  }

  set altura(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "altura" deve ser um número finito.');
    }
    if (valor &lt; 0) {
      throw new TypeError('O valor de "altura" deve ser um número não negativo.');
    }
    this.#canvas.height = valor;
  }

  get altura() {
    return this.#canvas.height;
  }

  set ratoX(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "ratoX" deve ser um número finito.');
    }
    this.#ratoX = valor * this.escalaX;
  }

  get ratoX() {
    return this.#ratoX;
  }

  set ratoY(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "ratoY" deve ser um número finito.');
    }
    this.#ratoY = valor * this.escalaY;
  }

  get ratoY() {
    return this.#ratoY;
  }

  /**
  * Contexto &lt;strong>2D&lt;/strong> da &lt;em>tela&lt;/em>, para acesso aos métodos nativamente disponibilizados pelo elemento &lt;code>canvas&lt;/code>, correspondente ao objecto &lt;code>CanvasRenderingContext2D&lt;/code> associado ao &lt;code>canvas&lt;/code> actualmente utilizado.
  * @type {CanvasRenderingContext2D}
  * @readonly
  */
  get contexto() {
    return this.#contexto;
  }

  /**
   * Código da tecla actualmente pressionada e &lt;em>identificada&lt;/em> através das propriedades &lt;code>processaTeclaDescida&lt;/code> e &lt;code>processaTeclaSubida&lt;/code>. Devolve &lt;code>undefined&lt;/code> quando nenhuma tecla se encontra pressionada ou identificada.
   * @type {string}
   * @readonly
   */
  get tecla() {
    return this.#tecla;
  }

  /**
   * Largura final da &lt;em>tela&lt;/em>, considerando quaisquer alterações decorrentes da utilização de &lt;em>CSS&lt;/em> para modificar a sua representação. Corresponde ao valor actual da propriedade &lt;code>offsetWidth&lt;/code> do elemento &lt;code>canvas&lt;/code>.
   * @type {number}
   * @readonly
   */
  get larguraFinal() {
    return this.#canvas.offsetWidth;
  }

  /**
   * Altura final da &lt;em>tela&lt;/em>, considerando quaisquer alterações decorrentes da utilização de &lt;em>CSS&lt;/em> para modificar a sua representação. Corresponde ao valor actual da propriedade &lt;code>offsetHeight&lt;/code> do elemento &lt;code>canvas&lt;/code>.
   * @type {number}
   * @readonly
   */
  get alturaFinal() {
    return this.#canvas.offsetHeight;
  }

  /**
   * Escala resultante do rácio entre a resolução do &lt;code>canvas&lt;/code> e a área ocupada pelo mesmo, relativa à largura (&lt;em>x&lt;/em>). Corresponde ao valor actual do quociente entre a largura do &lt;em>canvas&lt;/em> e a largura final ocupada pelo mesmo. Se a largura final for igual a zero, devolve &lt;code>1&lt;/code>.
   * @type {number}
   * @readonly
   */
  get escalaX() {
    let ratio = 1;
    if (this.larguraFinal !== 0) {
      ratio = this.largura / this.larguraFinal;
    }
    return ratio;
  }

  /**
   * Escala resultante do rácio entre a resolução do &lt;code>canvas&lt;/code> e a área ocupada pelo mesmo, relativa à altura (&lt;em>y&lt;/em>. Corresponde ao valor actual do quociente entre a altura do &lt;em>canvas&lt;/em> e a altura final ocupada pelo mesmo. Se a altura final for igual a zero, devolve &lt;code>1&lt;/code>.
   * @type {number}
   * @readonly
   */
  get escalaY() {
    let racio = 1;
    if (this.alturaFinal !== 0) {
      racio = this.altura / this.alturaFinal;
    }
    return racio;
  }

  /**
   * Adiciona um &lt;em>gráfico&lt;/em> (ou um &lt;em>array&lt;/em> de &lt;em>gráficos&lt;/em>) ao &lt;em>array&lt;/em> interno de &lt;em>gráficos&lt;/em> da &lt;em>tela&lt;/em>, associando uma ordem, para que seja posteriormente desenhado.
   * O argumento pode ser um único &lt;em>gráfico&lt;/em> ou um &lt;em>array&lt;/em> de &lt;em>gráficos&lt;/em> a adicionar. Cada &lt;em>gráfico&lt;/em> será adicionado com a ordem especificada.
   *
   * @param {Grafico|Grafico[]} grafico Um único &lt;em>gráfico&lt;/em> ou um &lt;em>array&lt;/em> de &lt;em>gráficos&lt;/em> a adicionar.
   * @param {number} [ordem=0] Ordem de desenho do(s) &lt;em>gráfico(s)&lt;/em> em relação aos outros.
   * @returns {number} O novo tamanho do &lt;em>array&lt;/em> interno de &lt;em>gráficos&lt;/em> após a adição.
   * @throws {TypeError} Se o parâmetro &lt;code>grafico&lt;/code> não for um objecto. Na prática, aceita qualquer objecto, ainda que depois não possa ser desenhado no método &lt;code>desenha()&lt;/code>.
   * @throws {TypeError} Se o parâmetro &lt;code>ordem&lt;/code> não for um número finito.
   */
  adiciona(grafico, ordem = 0) {
    if (typeof grafico !== 'object') {
      throw new TypeError('O parâmetro "grafico" deve ser um objecto não nulo: idealmente um objecto do tipo "Grafico" ou um "array".');
    }
    if (typeof ordem !== 'number' || !Number.isFinite(ordem)) {
      throw new TypeError('O parâmetro "ordem" deve ser um número finito.');
    }
    let tamanho = this.#graficos.push({ grafico, ordem });
    this.#graficos.sort((a, b) => a.ordem - b.ordem);
    return tamanho;
  }

  /**
   * Obtém a ordem associada a um &lt;em>gráfico&lt;/em> armazenado no &lt;em>array&lt;/em> interno de &lt;em>gráficos&lt;/em> da &lt;em>tela&lt;/em>. Devolve o valor da ordem do &lt;em>gráfico&lt;/em>, se este for encontrado; caso contrário, devolve &lt;code>undefined&lt;/code>.
   * @param {Grafico} grafico O &lt;em>gráfico&lt;/em> cuja ordem se pretende obter.
   * @returns {number|undefined} O valor da ordem do &lt;em>gráfico&lt;/em>, se for encontrado; caso contrário, &lt;code>undefined&lt;/code>.
   * @throws {TypeError} Se o parâmetro &lt;code>grafico&lt;/code> não for um objecto. Na prática, aceita qualquer objecto, ainda que depois não possa ser desenhado no método &lt;code>desenha()&lt;/code>.
   */
  obtemOrdem(grafico) {
    if (typeof grafico !== 'object') {
      throw new TypeError('O parâmetro "grafico" deve ser um objecto não nulo: idealmente um objecto do tipo "Grafico" ou um "array".');
    }
    let involucro = this.#graficos.find(elemento => elemento.grafico === grafico);
    if (involucro) {
      return involucro.ordem;
    }
    else {
      return undefined;
    }
  }

  /**
   * Altera a ordem de um &lt;em>gráfico&lt;/em> já adicionado ao &lt;em>array&lt;/em> interno de &lt;em>gráficos&lt;/em> da &lt;em>tela&lt;/em>. Se o &lt;em>gráfico&lt;/em> for encontrado, a sua ordem é actualizada e o &lt;em>array&lt;/em> interno de &lt;em>gráficos&lt;/em> é reordenado de acordo com o novo valor.
   * @param {Grafico} grafico O &lt;em>gráfico&lt;/em> cuja ordem se pretende alterar.
   * @param {number} [ordem=0] O valor da ordem do &lt;em>gráfico&lt;/em>.
   * @returns {boolean} Se o &lt;em>gráfico&lt;/em> foi encontrado e a ordem alterada, &lt;code>true&lt;/code>; caso contrário, &lt;code>false&lt;/code>.
   * @throws {TypeError} Se o parâmetro &lt;code>grafico&lt;/code> não for um objecto. Na prática, aceita qualquer objecto, ainda que depois não possa ser desenhado no método &lt;code>desenha()&lt;/code>.
   * @throws {TypeError} Se o parâmetro &lt;code>ordem&lt;/code> não for um número finito.
   */
  alteraOrdem(grafico, ordem = 0) {
    if (typeof grafico !== 'object') {
      throw new TypeError('O parâmetro "grafico" deve ser um objecto não nulo: idealmente um objecto do tipo "Grafico" ou um "array".');
    }
    if (typeof ordem !== 'number' || !Number.isFinite(ordem)) {
      throw new TypeError('O parâmetro "ordem" deve ser um número finito.');
    }
    let involucro = this.#graficos.find(elemento => elemento.grafico === grafico);
    if (!involucro) {
      return false;
    }
    else {
      involucro.ordem = ordem;
      this.#graficos.sort((a, b) => a.ordem - b.ordem);
      return true;
    }
  }

  /**
   * Remove &lt;em>gráficos&lt;/em> (ou &lt;em>arrays&lt;/em> de gráficos) do &lt;em>array&lt;/em> interno de &lt;em>gráficos&lt;/em> a serem desenhados na &lt;em>tela&lt;/em>. O argumento pode ser um único &lt;em>gráfico&lt;/em> ou um &lt;em>array&lt;/em> de &lt;em>gráficos&lt;/em> a remover.
   * @param {Grafico|Grafico[]} grafico Um único &lt;em>gráfico&lt;/em> ou um &lt;em>array&lt;/em> de &lt;em>gráficos&lt;/em> a remover.
   * @returns {boolean} Se algum &lt;em>gráfico&lt;/em> foi removido, &lt;code>true&lt;/code>; caso contrário, &lt;code>false&lt;/code>.
   * @throws {TypeError} Se o parâmetro &lt;code>grafico&lt;/code> não for um objecto. Na prática, aceita qualquer objecto, ainda que depois não possa ser desenhado no método &lt;code>desenha()&lt;/code>.
   */
  remove(grafico) {
    if (typeof grafico !== 'object') {
      throw new TypeError('O parâmetro "grafico" deve ser um objecto não nulo: idealmente um objecto do tipo "Grafico" ou um "array".');
    }
    let tamanhoAnterior = this.#graficos.length;
    this.#graficos = this.#graficos.filter(elemento => elemento.grafico !== grafico);
    return this.#graficos.length &lt; tamanhoAnterior;
  }

  /**
   * Limpa a tela, sendo especialmente útil na criação de animações, para evitar o efeito de arrastamento. Este método apaga todo o conteúdo actualmente desenhado no &lt;code>canvas&lt;/code>, preparando-o para uma nova iteração de desenho.
   */
  limpa() {
    this.contexto.clearRect(0, 0, this.largura, this.altura);
  }

  /**
   * Desenha todos os &lt;em>gráficos&lt;/em> (instâncias ou objectos de subclasses da classe &lt;code>Grafico&lt;/code>) que tenham sido adicionados a esta &lt;em>tela&lt;/em>. Opcionalmente, pode receber como argumento o &lt;em>tempo&lt;/em> referente ao momento da chamada, permitindo a uniformização das animações e dos movimentos entre diferentes dispositivos. Se este argumento for usado, as &lt;em>variações&lt;/em> das coordenadas dos &lt;em>gráficos&lt;/em> devem ser expressas em função de um segundo &amp;mdash; i.e., &lt;em>pixels&lt;/em> por segundo; caso contrário, assume-se que a &lt;em>variação&lt;/em> é definida em função de cada iteração &amp;mdash; i.e., &lt;em>pixels&lt;/em> por chamada ao método &lt;code>desenha()&lt;/code> dos &lt;em>gráficos&lt;/em>.
   * @param {number} [tempoActual] &lt;em>Tempo&lt;/em> referente ao momento da chamada (em milissegundos, idealmente obtido via &lt;code>performance.now()&lt;/code>).
   * @throws {TypeError} Se o parâmetro &lt;code>tempoActual&lt;/code> não for um número finito e não negativo.
   * @throws {RangeError} Se o parâmetro &lt;code>tempoActual&lt;/code> for um número negativo.
   */
  desenha(tempoActual) {
    if (tempoActual != null &amp;&amp; (typeof tempoActual !== 'number' || !Number.isFinite(tempoActual))) {
      throw new TypeError('O parâmetro "tempoActual", se não for nulo, deve ser um número finito.');
    }
    if (tempoActual &lt; 0) {
      throw new RangeError('O parâmetro "tempoActual" deve ser um número não negativo.');
    }
    let deltaTempo = 1 / 60;  // valor por omissão, para 60 fps
    if (tempoActual) {
      if (this.#tempoAnterior === undefined) {
        this.#tempoAnterior = tempoActual;
      }
      deltaTempo = (tempoActual - this.#tempoAnterior) / 1000;
      this.#tempoAnterior = tempoActual;
    }
    deltaTempo = Math.min(Tela.MAX_DELTA_TEMPO, Math.max(0, deltaTempo));
    this.#desenha(this.#graficos, deltaTempo);

  }

  #desenha(graficos, deltaTempo = 1) {
    for (let elemento of graficos) {
      if (Array.isArray(elemento.grafico)) {
        this.#desenha(elemento.grafico, deltaTempo);
      }
      else if (elemento.grafico) {
        elemento.grafico.desenha(this, deltaTempo);
      }
      else if (Array.isArray(elemento)) {
        this.#desenha(elemento, deltaTempo);
      }
      else {
        elemento.desenha(this, deltaTempo);
      }
    }
  }

  /**
   * Lista dos valores válidos para a propriedade &lt;code>cursor&lt;/code> em elementos de &lt;em>canvas&lt;/em> ou &lt;em>gráficos&lt;/em>, seguindo as especificações CSS e permitindo controlar a aparência do cursor do rato.
   * @type {string[]}
   * @static
   * @const
   * */
  static CURSORES = ['default', 'pointer', 'grab', 'grabbing', 'move', 'crosshair', 'wait', 'progress', 'not-allowed', 'zoom-in', 'zoom-out'];

  /**
   * Valor máximo permitido para o parâmetro &lt;code>deltaTempo&lt;/code> em actualizações e animações de &lt;em>gráficos&lt;/em>, sendo usado para limitar o intervalo de tempo entre fotogramas e garantir estabilidade nas animações nos momentos em que estas possam ser interrompidas.
   * @type {number}
   * @static
   * @const
   */
  static MAX_DELTA_TEMPO = 1 / 30;  // valor máximo, para um pior cenário de 30 fps -- ajustar se houver suspeitas de que, mesmo assim, deveria ser maior
}

//

/**
 * @class
 * @abstract
 * @classdesc A classe &lt;code>Media&lt;/code> é, na prática, uma classe &lt;em>abstracta&lt;/em>, servindo apenas de base para as subclasses de &lt;code>Media&lt;/code>. Para além disso, funcionará essencialmente como um &lt;em>invólucro&lt;/em> para elementos de &lt;code>audio&lt;/code> e de &lt;code>video&lt;/code> em eventuais subclasses.
 * @property {HTMLMediaElement} media O &lt;em>elemento&lt;/em> HTML &lt;em>media&lt;/em> a ser representado.
 * @property {number} posicao O tempo actual de reprodução (em segundos) do elemento de &lt;em>media&lt;/em>. Pode variar entre &lt;code>0.0&lt;/code> e &lt;code>duracao&lt;/code>. Se o valor atribuído estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code> (se inferior) ou &lt;code>duracao&lt;/code> (se superior).
 * @property {number} duracao A duração total do elemento de &lt;em>media&lt;/em> (em segundos).
 * @property {number} volume O volume actual do elemento de &lt;em>media&lt;/em>. Pode variar entre &lt;code>0.0&lt;/code> e &lt;code>1.0&lt;/code>. Se o valor atribuído estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code> (se inferior) ou &lt;code>1.0&lt;/code> (se superior).
 */
class Media {
  #media;

  /**
   * Construtor da classe &lt;code>Media&lt;/code> &amp;mdash; &lt;em>este construtor não deve ser usado directamente; se tal acontecer, é gerada uma excepção (&lt;code>TypeError&lt;/code>)&lt;/em>.
   * @param {HTMLMediaElement} media O &lt;em>elemento&lt;/em> &lt;code>HTMLMediaElement&lt;/code> a ser representado.
   * @throws {TypeError} Caso a classe seja instanciada directamente &amp;mdash; não permitido (classe abstracta).
   * @throws {TypeError} Caso &lt;code>media&lt;/code> não seja do tipo &lt;code>HTMLMediaElement&lt;/code>.
   */
  constructor(media) {
    if (this.constructor.name === 'Media') {
      throw new TypeError('A classe abstracta "Media" não pode ser instanciada directamente, devendo ser implementada através de subclasses (que poderão depois ser instanciadas).');
    }
    if (!(media instanceof HTMLMediaElement)) {
      throw new TypeError('O parâmetro "media" deve ser um objecto do tipo "HTMLMediaElement".');
    }
    this.#media = media;
    const tiposEventosMedia = ['play', 'playing', 'pause', 'ended', 'timeupdate', 'volumechange'];
    for (const tipoEventoMedia of tiposEventosMedia) {
      this.#media.addEventListener(tipoEventoMedia, (evento) => this.#processaMedia(evento));
    }
  }

  #processaMedia(evento) {
    switch (evento.type) {
      case 'play':
        this.processaReproducaoIniciada(evento);
        break;
      case 'playing':
        this.processaReproducaoContinuada(evento);
        break;
      case 'pause':
        this.processaReproducaoPausada(evento);
        break;
      case 'ended':
        this.processaReproducaoTerminada(evento);
        break;
      case 'timeupdate':
        this.processaTempoActualizado(evento);
        break;
      case 'volumechange':
        this.processaVolumeAlterado(evento);
        break;
      default:
        break;
    }
  }

  /**
   * Método chamado quando ocorre o &lt;em>evento&lt;/em> &lt;code>play&lt;/code>, que deverá ser posteriormente definido como uma &lt;em>função&lt;/em> contendo as instruções a executar decorrentes desse evento.
   * @param {Event} evento Objecto correspondente ao evento &lt;code>play&lt;/code> que foi desencadeado.
   */
  processaReproducaoIniciada(evento) { }

  /**
   * Método chamado quando ocorre o &lt;em>evento&lt;/em> &lt;code>playing&lt;/code>, que deverá ser posteriormente definido como uma &lt;em>função&lt;/em> contendo as instruções a executar decorrentes desse evento.
   * @param {Event} evento Objecto correspondente ao evento &lt;code>playing&lt;/code> que foi desencadeado.
   */
  processaReproducaoContinuada(evento) { }

  /**
   * Método chamado quando ocorre o &lt;em>evento&lt;/em> &lt;code>pause&lt;/code>, que deverá ser posteriormente definido como uma &lt;em>função&lt;/em> contendo as instruções a executar decorrentes desse evento.
   * @param {Event} evento Objecto correspondente ao evento &lt;code>pause&lt;/code> que foi desencadeado.
   */
  processaReproducaoPausada(evento) { }

  /**
   * Método chamado quando ocorre o &lt;em>evento&lt;/em> &lt;code>ended&lt;/code>, que deverá ser posteriormente definido como uma &lt;em>função&lt;/em> contendo as instruções a executar decorrentes desse evento.
   * @param {Event} evento Objecto correspondente ao evento &lt;code>ended&lt;/code> que foi desencadeado.
   */
  processaReproducaoTerminada(evento) { }

  /**
   * Método chamado quando ocorre o &lt;em>evento&lt;/em> &lt;code>timeupdate&lt;/code>, que deverá ser posteriormente definido como uma &lt;em>função&lt;/em> contendo as instruções a executar decorrentes desse evento.
   * @param {Event} evento Objecto correspondente ao evento &lt;code>timeupdate&lt;/code> que foi desencadeado.
   */
  processaTempoActualizado(evento) { }

  /**
   * Método chamado quando ocorre o &lt;em>evento&lt;/em> &lt;code>volumechange&lt;/code>, que deverá ser posteriormente definido como uma &lt;em>função&lt;/em> contendo as instruções a executar decorrentes desse evento.
   * @param {Event} evento Objecto correspondente ao evento &lt;code>volumechange&lt;/code> que foi desencadeado.
   */
  processaVolumeAlterado(evento) { }

  set media(valor) {
    if (!(valor instanceof HTMLMediaElement)) {
      throw new TypeError('O valor de "media" deve ser um objecto do tipo "HTMLMediaElement".');
    }
    this.#media = valor;
  }

  get media() {
    return this.#media;
  }

  set volume(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "volume" deve ser um número finito, idealmente entre 0.0 e 1.0.');
    }
    this.#media.volume = Math.min(1, Math.max(0, valor));
  }

  get volume() {
    return this.#media.volume;
  }

  set posicao(valor) {
    if (typeof valor !== 'number' || !Number.isFinite(valor)) {
      throw new TypeError('O valor de "posicao" deve ser um número finito, idealmente entre 0.0 e a duração do elemento de media.');
    }
    this.#media.currentTime = Math.min(this.media.duration, Math.max(0, valor))
  }

  get posicao() {
    return this.#media.currentTime;
  }

  /**
   * Duração da reprodução do elemento multimédia, correspondente ao valor actual da propriedade &lt;code>duration&lt;/code> do elemento associado. Se a duração não estiver disponível, devolve &lt;code>NaN&lt;/code>.
   * @type {number}
   * @readonly
   */
  get duracao() {
    return this.#media.duration;
  }

  /**
   * Inicia ou retoma a reprodução do elemento multimédia. Caso o parâmetro &lt;code>inicio&lt;/code> seja &lt;code>true&lt;/code>, a reprodução é iniciada desde o início; caso contrário, é retomada a partir do momento em que foi interrompida anteriormente (ou do momento indicado pelo tempo de reprodução), ou continua a sua reprodução (se já estava a ser reproduzido).
   * @param {boolean} [inicio=false] Indicação de que o elemento deve ser reproduzido do início; caso contrário, é reproduzido a partir do momento em que foi interrompida a sua reprodução anterior (ou do momento indicado pelo tempo de reprodução), ou continua a sua reprodução (se já estava a ser reproduzido).
   * @throws {TypeError} Se o parâmetro &lt;code>inicio&lt;/code> não for do tipo booleano.
   */
  reproduz(inicio = false) {
    if (typeof inicio !== 'boolean') {
      throw new TypeError('O parâmetro "inicio" deve ser do tipo booleano.');
    }
    if (inicio) {
      this.#media.currentTime = 0;
    }
    this.#media.play();
  }

  /**
   * Pára a reprodução do elemento multimédia. Este método interrompe temporariamente a reprodução, podendo esta ser retomada posteriormente a partir do ponto onde foi interrompida.
   */
  pausa() {
    this.#media.pause();
  }

  /**
   * Pára a reprodução do elemento multimédia, voltando também ao seu início. Este método interrompe a reprodução (caso esteja a decorrer) e repõe o tempo actual de reprodução no início (&lt;code>0&lt;/code>).
   */
  para() {
    this.pausa();
    this.#media.currentTime = 0;
  }
}

/**
 * @class
 * @extends Media
 * @classdesc A classe &lt;code>Som&lt;/code> funciona essencialmente como um &lt;em>invólucro&lt;/em> para elementos &lt;code>HTMLAudioElement&lt;/code>, facilitando a sua referenciação e também o uso dos métodos mais comuns para, por exemplo, o controlo da sua reprodução.
 * @property {HTMLAudioElement} som O &lt;em>elemento&lt;/em> do tipo &lt;code>HTMLAudioElement&lt;/code> a ser representado.
 * @property {number} posicao O tempo actual de reprodução (em segundos) do &lt;em>som&lt;/em>. Pode variar entre &lt;code>0.0&lt;/code> e &lt;code>duracao&lt;/code>. Se o valor atribuído estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code> (se inferior) ou &lt;code>duracao&lt;/code> (se superior).
 * @property {number} duracao A duração total do &lt;em>som&lt;/em> (em segundos).
 * @property {number} volume O volume actual do &lt;em>som&lt;/em>. Pode variar entre &lt;code>0.0&lt;/code> e &lt;code>1.0&lt;/code>. Se o valor atribuído estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code> (se inferior) ou &lt;code>1.0&lt;/code> (se superior).
 */
class Som extends Media {

  /**
   * Construtor para criação de novos objectos do tipo &lt;code>Som&lt;/code>. Inicializa a instância com o elemento HTML do tipo &lt;code>audio&lt;/code> a ser representado.
   * @param {HTMLAudioElement} som O &lt;em>elemento&lt;/em> do tipo &lt;code>HTMLAudioElement&lt;/code> a ser representado.
   * @throws {TypeError} Se o parâmetro &lt;code>audio&lt;/code> não for um objecto do tipo &lt;code>HTMLAudioElement&lt;/code>.
   */
  constructor(som) {
    super(som);
    if (!(som instanceof HTMLAudioElement)) {
      throw new TypeError('O parâmetro "som" deve ser um objecto do tipo "HTMLAudioElement".');
    }
  }

  set som(valor) {
    if (!(valor instanceof HTMLAudioElement)) {
      throw new TypeError('O valor de "som" deve ser um objecto do tipo "HTMLAudioElement".');
    }
    super.media = valor;
  }

  get som() {
    return super.media;
  }
}

//

/**
 * @class
 * @extends Media
 * @classdesc A classe &lt;code>Filme&lt;/code> funciona essencialmente como um &lt;em>invólucro&lt;/em> para elementos &lt;code>HTMLVideoElement&lt;/code>, facilitando a sua referenciação e também uso de métodos mais comuns para, por exemplo, o controlo da sua reprodução.
 * @property {HTMLVideoElement} video O &lt;em>elemento&lt;/em> do tipo &lt;code>HTMLVideoElement&lt;/code> a ser representado.
 * @property {number} posicao O tempo actual de reprodução (em segundos) do &lt;em>filme&lt;/em>. Pode variar entre &lt;code>0.0&lt;/code> e &lt;code>duracao&lt;/code>. Se o valor atribuído estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code> (se inferior) ou &lt;code>duracao&lt;/code> (se superior).
 * @property {number} duracao A duração total do &lt;em>filme&lt;/em> (em segundos).
 * @property {number} volume O volume actual do &lt;em>filme&lt;/em>. Pode variar entre &lt;code>0.0&lt;/code> e &lt;code>1.0&lt;/code>. Se o valor atribuído estiver fora deste intervalo, será corrigido para &lt;code>0.0&lt;/code> (se inferior) ou &lt;code>1.0&lt;/code> (se superior).
 */
class Filme extends Media {

  /**
   * Construtor para a criação de novos objectos do tipo &lt;code>Filme&lt;/code>. Inicializa a instância com o elemento HTML do tipo &lt;code>video&lt;/code> a ser representado.
   * @param {HTMLVideoElement} filme O &lt;em>elemento&lt;/em> do tipo &lt;code>HTMLVideoElement&lt;/code> a ser representado.
   * @throws {TypeError} Se o parâmetro &lt;code>video&lt;/code> não for um objecto do tipo &lt;code>HTMLVideoElement&lt;/code>.
   */
  constructor(filme) {
    super(filme);
    if (!(filme instanceof HTMLVideoElement)) {
      throw new TypeError('O parâmetro "filme" deve ser um objecto do tipo "HTMLVideoElement".');
    }
  }

  set filme(valor) {
    if (!(valor instanceof HTMLVideoElement)) {
      throw new TypeError('O valor de "filme" deve ser um objecto do tipo "HTMLVideoElement".');
    }
    super.media = valor;
  }

  get filme() {
    return super.media;
  }

  /**
   * Largura do &lt;em>filme&lt;/em> (número de colunas), correspondente ao valor actual da propriedade &lt;code>videoWidth&lt;/code> do elemento associado ao &lt;em>filme&lt;/em>.
   * @type {number}
   * @readonly
   */
  get largura() {
    return this.media.videoWidth;
  }

  /**
   * Altura do &lt;em>filme&lt;/em> (número de linhas), correspondente ao valor actual da propriedade &lt;code>videoHeight&lt;/code> do elemento associado ao &lt;em>filme&lt;/em>.
   * @type {number}
   * @readonly
   */
  get altura() {
    return this.media.videoHeight;
  }
}

//

/**
 * @class
 * @classdesc A classe &lt;code>Cronometro&lt;/code> permite obter o tempo (decorrido ou parado) entre quaisquer dois momentos no tempo, facilitando a medição de intervalos temporais.
 * @property {boolean} parado Indica se o &lt;em>cronómetro&lt;/em> está parado (&lt;code>true&lt;/code>) ou em funcionamento (&lt;code>false&lt;/code>).
 * @property {number} tempoInicial Instante (em milissegundos) em que o &lt;em>cronómetro&lt;/em> foi criado ou reiniciado pela última vez.
 * @property {number} tempoDecorrido Tempo, em milissegundos, efectivamente contado pelo &lt;em>cronómetro&lt;/em> desde a sua criação ou último reinício.
 * @property {number} tempoParado Tempo, em milissegundos, durante o qual o &lt;em>cronómetro&lt;/em> esteve parado desde a sua criação ou último reinício.
 */
class Cronometro {
  #tempoReferencia;
  #tempoDecorrido;
  #tempoInicial;
  #parado;

  /**
   * Construtor para criação de novos objectos do tipo &lt;code>Cronometro&lt;/code>. Inicializa o &lt;em>cronómetro&lt;/em>, definindo o instante de referência e o tempo inicial como o momento actual, com o tempo decorrido a zero e o &lt;em>cronómetro&lt;/em> em funcionamento.
   */
  constructor() {
    this.#tempoInicial = performance.now();
    this.#tempoReferencia = this.#tempoInicial;
    this.#tempoDecorrido = 0;
    this.#parado = false;
  }

  /**
   * Estado actual do &lt;em>cronómetro&lt;/em>: parado (&lt;code>true&lt;/code>) ou a contar o tempo (&lt;code>false&lt;/code>).
   * @type {boolean}
   * @readonly
   */
  get parado() {
    return this.#parado;
  }

  /**
  * Instante (em milissegundos) em que o &lt;em>cronómetro&lt;/em> foi criado ou reiniciado pela última vez.
  * @type {number}
  * @readonly
  */
  get tempoInicial() {
    return this.#tempoInicial;
  }

  /**
   * Tempo decorrido, em milissegundos, desde que o &lt;em>cronómetro&lt;/em> foi criado ou reiniciado. Se o &lt;em>cronómetro&lt;/em> estiver parado, o tempo decorrido mantém-se inalterado enquanto essa situação se verificar. Caso esteja a contar, devolve o tempo total acumulado até ao momento actual.
   * @type {number}
   * @readonly
   */
  get tempoDecorrido() {
    if (this.#parado) {
      return this.#tempoDecorrido;
    }
    else {
      return performance.now() - this.#tempoReferencia + this.#tempoDecorrido;
    }
  }

  /**
   * Tempo, em milissegundos, durante o qual o &lt;em>cronómetro&lt;/em> esteve parado desde que foi criado ou reiniciado, correspondendo à diferença entre o tempo total decorrido e o tempo efectivamente contado pelo &lt;em>cronómetro&lt;/em>.
   * @type {number}
   * @readonly
   */
  get tempoParado() {
    return performance.now() - this.#tempoInicial - this.tempoDecorrido;
  }

  /**
   * Faz com que o &lt;em>cronómetro&lt;/em> volte a contar o tempo decorrido desde que foi criado ou reiniciado, deixando de contar o tempo durante o qual esteve parado.
   * @param {number} [agora=performance.now()] Instante (em milissegundos) a considerar como momento de retoma da contagem do tempo decorrido. Se não for fornecido, será usado o tempo actual do sistema.
   * @throws {TypeError} Se o parâmetro &lt;code>agora&lt;/code> não for um número finito.
   * @throws {RangeError} Se o parâmetro &lt;code>agora&lt;/code> for um número negativo.
   */
  continua(agora = performance.now()) {
    if (typeof agora !== 'number' || !Number.isFinite(agora)) {
      throw new TypeError('O parâmetro "agora" deve ser um número finito.');
    }
    if (agora &lt; 0) {
      throw new RangeError('O parâmetro "agora" deve ser um número não negativo.');
    }
    if (this.#parado) {
      this.#tempoReferencia = agora;
      this.#parado = false;
    }
  }

  /**
   * Pára o &lt;em>cronómetro&lt;/em>, interrompendo a contagem do tempo decorrido desde que foi criado ou reiniciado. O tempo decorrido mantém-se inalterado enquanto o &lt;em>cronómetro&lt;/em> estiver parado, ao passo que o tempo parado vai aumenta.
   * @param {number} [agora=performance.now()] Instante (em milissegundos) a considerar como momento da paragem. Se não for fornecido, será usado o tempo actual do sistema.
   * @throws {TypeError} Se o parâmetro &lt;code>agora&lt;/code> não for um número finito.
   * @throws {RangeError} Se o parâmetro &lt;code>agora&lt;/code> for um número negativo.
   */
  para(agora = performance.now()) {
    if (typeof agora !== 'number' || !Number.isFinite(agora)) {
      throw new TypeError('O parâmetro "agora" deve ser um número finito.');
    }
    if (agora &lt; 0) {
      throw new RangeError('O parâmetro "agora" deve ser um número não negativo.');
    }
    if (!this.#parado) {
      this.#tempoDecorrido += agora - this.#tempoReferencia;
      this.#parado = true;
    }
  }

  /**
   * Reinicia o &lt;em>cronómetro&lt;/em>, definindo o instante actual (ou o valor fornecido) como novo tempo inicial e de referência, colocando o tempo decorrido e o tempo parado a zero, e iniciando imediatamente a contagem do tempo.
   * @param {number} [agora=performance.now()] Instante (em milissegundos) a considerar como novo tempo inicial e de referência. Se não for fornecido, será usado o tempo actual do sistema.
   * @throws {TypeError} Se o parâmetro &lt;code>agora&lt;/code> não for um número finito.
   * @throws {RangeError} Se o parâmetro &lt;code>agora&lt;/code> for um número negativo.
   */
  reinicia(agora = performance.now()) {
    if (typeof agora !== 'number' || !Number.isFinite(agora)) {
      throw new TypeError('O parâmetro "agora" deve ser um número finito.');
    }
    if (agora &lt; 0) {
      throw new RangeError('O parâmetro "agora" deve ser um número não negativo.');
    }
    this.#tempoInicial = agora;
    this.#tempoReferencia = agora;
    this.#tempoDecorrido = 0;
    this.#parado = false;
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Circulo.html">Circulo</a></li><li><a href="Cronometro.html">Cronometro</a></li><li><a href="Filme.html">Filme</a></li><li><a href="Grafico.html">Grafico</a></li><li><a href="Imagem.html">Imagem</a></li><li><a href="ImagemAnimada.html">ImagemAnimada</a></li><li><a href="ImagemFilme.html">ImagemFilme</a></li><li><a href="Media.html">Media</a></li><li><a href="PadraoImagem.html">PadraoImagem</a></li><li><a href="Poligono.html">Poligono</a></li><li><a href="Rectangulo.html">Rectangulo</a></li><li><a href="Som.html">Som</a></li><li><a href="Tela.html">Tela</a></li><li><a href="Texto.html">Texto</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Sun May 18 2025 23:56:19 GMT+0100 (Western European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
