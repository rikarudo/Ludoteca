<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Ludoteca.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Ludoteca.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file Biblioteca de classes que representam os tipos mais comuns de &lt;em>gráficos&lt;/em> a desenhar num &lt;code>canvas&lt;/code> e também o próprio &lt;code>canvas&lt;/code>, bem como os elementos &lt;code>audio&lt;/code> e &lt;code>video&lt;/code>. O propósito desta biblioteca é facilitar o desenvolvimento de jogos e outras aplicações multimédia num contexto académico, gerando-se algum nível de abstracção relativamente a alguns pormenores do código. Abordam-se apenas os tipos mais frequentes de gráficos e de elementos acessórios, evitando, quando possível, complexidade desnecessária.
 * @version 0.9.3
 * @author Ricardo Rodrigues
 * @date 2023-04-17
 * @copyright Ricardo Rodrigues (2021, 2022, 2023)
 */

//

/**
 * @class
 * @classdesc A classe &lt;code>Grafico&lt;/code> é, para todos os efeitos, uma classe &lt;em>abstracta&lt;/em>, um esqueleto, servindo apenas de base para as subclasses de &lt;code>Grafico&lt;/code>.
 * @property {number} x Abscissa para posicionar o &lt;em>gráfico&lt;/em> no &lt;code>canvas&lt;/code>
 * @property {number} y Ordenada para posicionar o &lt;em>gráfico&lt;/em> no &lt;code>canvas&lt;/code>
 * @property {number} deltaX=0 Variação horizontal da posição do &lt;em>gráfico&lt;/em>
 * @property {number} deltaY=0 Variação vertical da posição do &lt;em>gráfico&lt;/em>
 * @property {number} distX=0 Distância horizontal até um dado ponto &amp;mdash; pode ser usada, por exemplo, para guardar o &lt;em>offset&lt;/em> do &lt;em>x&lt;/em> em relação à posição &lt;em>x&lt;/em> do cursor do rato
 * @property {number} distY=0 Distância vertical até um dado ponto &amp;mdash; pode ser usada, por exemplo, para guardar o &lt;em>offset&lt;/em> do &lt;em>y&lt;/em> em relação à posição &lt;em>y&lt;/em> do cursor do rato
 * @property {number} angulo=0 Ângulo de rotação do &lt;em>gráfico&lt;/em> quando desenhado no &lt;code>canvas&lt;/code> &amp;mdash; a rotação é feita tendo como referência o centro do &lt;em>gráfico&lt;/em>
 * @property {number} gravidade=0 Força que, quando usada em conjunto com o &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação vertical do &lt;em>gráfico&lt;/em>, actuando como a &lt;em>gravidade&lt;/em>
 * @property {number} velocidade=0 Velocidade que, quando usada em conjunto com o &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação horizontal e vertical do &lt;em>gráfico&lt;/em>
 * @property {boolean} activo=true Indicação de que o &lt;em>gráfico&lt;/em> deve testar colisões, quando chamado o método &lt;code>colide(outro)&lt;/code>
 * @property {boolean} rotacao=false Indicação de que o &lt;em>gráfico&lt;/em> deve rodar, reflectindo o seu &lt;em>ângulo&lt;/em>
 * @property {boolean} visivel=true Indicação de que o &lt;em>gráfico&lt;/em> deve ser desenhado no &lt;code>canvas&lt;/code>, quando chamado o método &lt;code>desenha(tela)&lt;/code>
 */
class Grafico {
  /**
   * Construtor da classe &lt;code>Grafico&lt;/code>. &lt;em>Este construtor não deve ser usado directamente. Se tal acontecer, é gerada uma excepção (&lt;code>TypeError&lt;/code>).&lt;/em>
   * @param {number} x Abscissa para posicionar o &lt;em>gráfico&lt;/em> no &lt;code>canvas&lt;/code>
   * @param {number} y Ordenada para posicionar o &lt;em>gráfico&lt;/em> no &lt;code>canvas&lt;/code>
   */
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.deltaX = 0;
    this.deltaY = 0;
    this.distX = 0;
    this.distY = 0;
    this.angulo = 0;
    this.gravidade = 0;
    this.velocidade = 0;
    this.activo = true;
    this.rotacao = false;
    this.visivel = true;
    if (this.constructor.name == "Grafico") {
      throw new TypeError("A classe abstracta 'Grafico' não pode ser instanciada directamente, devendo ser implementada através de subclasses (que poderão então ser instanciadas).");
    }
  }

  /**
   * Este método verifica se existe uma colisão entre &lt;em>este gráfico&lt;/em> e &lt;em>outro&lt;/em>. Tal acontece quando um dos pontos de um &lt;em>gráfico&lt;/em> se encontra contido na área de &lt;em>outro&lt;/em>. Para o efeito, são usados os pontos que definem o &lt;em>envelope&lt;/em> de cada &lt;em>gráfico&lt;/em>. Este método também permite, caso se verifique a colisão, reposicionar &lt;em>este gráfico&lt;/em>, deixando-o encostado (ou próximo disso, consoante o &lt;em>afastamento&lt;/em>) ao &lt;em>outro&lt;/em>, evitando a sobreposição de ambos. O &lt;em>reposicionamento&lt;/em> depende da posição imediatamente anterior &lt;em>deste gráfico&lt;/em> em relação ao &lt;em>outro&lt;/em>. &lt;em>[Neste momento, o reposicionamento ainda só funciona devidamente com movimentos definidos pelo &lt;code>deltaX&lt;/code>, pelo &lt;code>deltaY&lt;/code> e pela &lt;code>gravidade&lt;/code>. Note-se também que as colisões são testadas em toda a área do gráfico, e não apenas em áreas específicas, como acontece no caso das caixas de colisão (&lt;em>hitboxes&lt;/em>), que ainda não se encontra implementadas.]&lt;/em>
   * @param {Grafico} outro Outro &lt;em>gráfico&lt;/em> para verificar se existe alguma colisão entre &lt;em>esse&lt;/em> e &lt;em>este&lt;/em>
   * @param {boolean} reposicionamento=true Indicação de que este &lt;em>gráfico&lt;/em> deve ser reposicionado (ou não) quando colide com o outro
   * @param {number} afastamento=0 Afastamento a aplicar entre os dois &lt;em>gráficos&lt;/em> no reposicionamento; idealmente, este deve ser compreendido entre zero (&lt;code>0&lt;/code>) e um valor inferior aos valores de quaisquer deslocamentos horizontais e verticais
   * @returns {boolean} Se houver colisão, &lt;code>true&lt;/code>, ou, no caso de se aplicar resposicionamento, &lt;code>1&lt;/code>, &lt;code>2&lt;/code>, &lt;code>3&lt;/code> ou &lt;code>4&lt;/code>, correspondentes às posições &lt;em>cima&lt;/em>, &lt;em>baixo&lt;/em>, &lt;em>esquerda&lt;/em> e &lt;em>direita&lt;/em>, respectivamente, e &lt;code>0&lt;/code>, se não tiver sido aplicado; senão, &lt;code>false&lt;/code>
   */
  colide(outro, reposicionamento = false, afastamento = 0) {
    if (!reposicionamento) {
      return (this.activo &amp;&amp; outro.activo &amp;&amp; (this.contemPontos(outro.envelope) || outro.contemPontos(this.envelope)));
    }
    else {
      if (this.activo &amp;&amp; outro.activo &amp;&amp; (this.contemPontos(outro.envelope) || outro.contemPontos(this.envelope))) {
        var posicao = Utilitarios.FALSO;
        // posicão anterior: em cima
        if (this.y + this.alturaEnvelope - Math.abs(this.deltaY + this.gravidade) &lt;= outro.y) {
          this.y = outro.y - this.alturaEnvelope - afastamento;
          posicao = Utilitarios.CIMA;
        }
        // posicão anterior: em baixo
        else if (this.y - outro.alturaEnvelope + Math.abs(this.deltaY + this.gravidade) >= outro.y) {
          this.y = outro.y + outro.alturaEnvelope + afastamento;
          posicao = Utilitarios.BAIXO;
        }
        // posicão anterior: à esquerda
        else if (this.x + this.larguraEnvelope - Math.abs(this.deltaX) &lt;= outro.x) {
          this.x = outro.x - this.larguraEnvelope - afastamento;
          posicao = Utilitarios.ESQUERDA;
        }
        // posicão anterior: à direita
        else if (this.x - outro.larguraEnvelope + Math.abs(this.deltaX) >= outro.x) {
          this.x = outro.x + outro.larguraEnvelope + afastamento;
          posicao = Utilitarios.DIREITA;
        }
        else {
          posicao = Utilitarios.FALSO;
        }
        return posicao;
      }
      else {
        return false;
      }
    }
  }

  /**
   * Este método mais não faz que chamar o método &lt;code>contemPonto(x, y)&lt;/code> para cada um dos pontos de um &lt;em>array&lt;/em>, verificando se algum deles se encontra dentro da área do &lt;em>gráfico&lt;/em>.
   * @param {array} pontos Conjunto de pontos a verificar se estão contidos no &lt;em>gráfico&lt;/em>
   * @returns {boolean} Se algum um dos pontos constantes no &lt;em>array&lt;/em> estiver contido neste &lt;em>grafico&lt;/em>, &lt;code>true&lt;/code>; senão, &lt;code>false&lt;/code>
   */
  contemPontos(pontos) {
    for (var i = 0; i &lt; pontos.length; i++) {
      if (this.contemPonto(pontos[i].x, pontos[i].y)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Este método verifica se um dado &lt;em>ponto&lt;/em> está contido na área do &lt;em>envelope&lt;/em> &lt;em>gráfico&lt;/em>, assumindo-se que o &lt;em>gráfico&lt;/em> é um &lt;em>polígono&lt;/em>. Assim, tal acontece quando um segmento de recta com início no ponto especificado intersecta um número ímpar de arestas do &lt;em>polígono&lt;/em>.
   * @param {number} x Abscissa do ponto a testar se está contido neste &lt;em>gráfico&lt;/em>
   * @param {number} y Ordenada do ponto a testar se está contido neste &lt;em>gráfico&lt;/em>
   * @returns {boolean} Se o ponto estiver contido neste &lt;em>gráfico&lt;/em>, &lt;code>true&lt;/code>; senão, &lt;code>false&lt;/code>
   */
  contemPonto(x, y) {
    var contido = 0;
    for (var i = 0, j = this.envelope.length - 1; i &lt; this.envelope.length; j = i++) {
      var pontoI = { x: this.envelope[i].x, y: this.envelope[i].y };
      var pontoJ = { x: this.envelope[j].x, y: this.envelope[j].y };
      if (((pontoI.y > y) != (pontoJ.y > y)) &amp;&amp; (x &lt; (pontoJ.x - pontoI.x) * (y - pontoI.y) / (pontoJ.y - pontoI.y) + pontoI.x)) {
        contido++;
      }
    }
    if (contido % 2 == 0) {
      return false;
    }
    return true;
  }

  /**
   * Largura do menor &lt;em>rectângulo imaginário&lt;/em> que envolva o &lt;em>gráfico&lt;/em>
   * @type {number}
   */
  get largura() {
    throw new Error("O método &lt;em>getter&lt;/em> 'largura()' tem de ser implementado nas subclasses da classe 'Grafico'.");
  }

  /**
   * Altura do menor &lt;em>rectângulo imaginário&lt;/em> que envolva o &lt;em>gráfico&lt;/em>
   * @type {number}
   */
  get altura() {
    throw new Error("O método &lt;em>getter&lt;/em> 'altura()' tem de ser implementado nas subclasses da classe 'Grafico'.");
  }

  /**
   * Centróide do &lt;em>gráfico&lt;/em> considerando os pontos dos seus vértices
   * @type {PontoCartesiano}
   */
  get centroide() {
    var centroideX = this.largura * 0.5;
    var centroideY = this.altura * 0.5;
    return { x: centroideX, y: centroideY };
  }

  /**
   * Conjunto de pontos que delimitam o &lt;em>gráfico&lt;/em>, definindo um &lt;em>envelope&lt;/em>
   * @type {array}
   */
  get envelope() {
    var verticesCartesianos = [{ x: 0, y: 0 }, { x: this.largura, y: 0 }, { x: this.largura, y: this.altura }, { x: 0, y: this.altura }];
    // para evitar processamento desnecessário, só se faz a criação do envelope com base na conversão das coordenadas cartesianas dos vertices em coordenadas polares e destas novamente em coordenadas cartesianas quando o ângulo é diferente de zero (0), já que, quando o ângulo tem esse valor, o resultado é idêntico a quando não se faz qualquer conversão
    if (this.rotacao &amp;&amp; this.angulo != 0) {
      var verticesPolares = new Array(verticesCartesianos.length);
      for (var i = 0; i &lt; verticesPolares.length; i++) {
        verticesPolares[i] = Utilitarios.calculaCoordenadasPolares(verticesCartesianos[i].x - this.centroide.x, verticesCartesianos[i].y - this.centroide.y);
      }
      var envelope = new Array(verticesPolares.length);
      for (var i = 0; i &lt; envelope.length; i++) {
        envelope[i] = { x: Utilitarios.calculaCoordenadasCartesianas(verticesPolares[i].distancia, verticesPolares[i].angulo + this.angulo).x + this.centroide.x + this.x, y: Utilitarios.calculaCoordenadasCartesianas(verticesPolares[i].distancia, verticesPolares[i].angulo + this.angulo).y + this.centroide.y + this.y };
      }
    }
    else {
      var envelope = new Array(verticesCartesianos.length);
      for (var i = 0; i &lt; envelope.length; i++) {
        envelope[i] = { x: verticesCartesianos[i].x + this.x, y: verticesCartesianos[i].y + this.y };
      }
    }
    return envelope;
  }

  /**
   * Largura do menor &lt;em>rectângulo imaginário&lt;/em> que envolva o &lt;em>envelope&lt;/em> deste &lt;em>gráfico&lt;/em> &amp;mdash; sendo definida pela distância entre o &lt;em>x&lt;/em>  do ponto mais à esquerda e o &lt;em>x&lt;/em> do ponto mais à direita do &lt;em>envelope&lt;/em>
   * @type {number}
   */
  get larguraEnvelope() {
    var minX = Number.MAX_VALUE;
    var maxX = Number.MIN_VALUE;
    for (var i = 0, j = this.envelope.length - 1; i &lt; this.envelope.length; j = i++) {
      minX = Math.min(minX, this.envelope[i].x);
      maxX = Math.max(maxX, this.envelope[j].x);
    }
    return maxX - minX;
  }

  /**
   * Altura do menor &lt;em>rectângulo imaginário&lt;/em> que envolva o &lt;em>envelope&lt;/em> deste &lt;em>gráfico&lt;/em> &amp;mdash; sendo definida pela distância entre o &lt;em>y&lt;/em> do ponto mais acima e o &lt;em>y&lt;/em> do ponto mais abaixo do &lt;em>envelope&lt;/em>
   * @type {number}
   */
  get alturaEnvelope() {
    var minY = Number.MAX_VALUE;
    var maxY = Number.MIN_VALUE;
    for (var i = 0, j = this.envelope.length - 1; i &lt; this.envelope.length; j = i++) {
      minY = Math.min(minY, this.envelope[i].y);
      maxY = Math.max(maxY, this.envelope[j].y);
    }
    return maxY - minY;
  }

  /**
   * &lt;em>Este método deve ser implementado nas subclasses de &lt;code>Grafico&lt;/code>, respeitando as especificidades de cada forma representada nelas. Se tal não acontecer, é gerada uma excepção (&lt;code>Error&lt;/code>).&lt;/em>
   * @param {Tela} tela Objecto que representa o elemento &lt;code>canvas&lt;/code> onde será desenhado o &lt;em>gráfico&lt;/em>
   */
  desenha(tela) {
    throw new Error("O método 'desenha(tela)' tem de ser implementado nas subclasses da classe 'Grafico'.");
  }
}

//

/**
 * @class
 * @extends Grafico
 * @classdesc A classe &lt;code>Circulo&lt;/code> é uma subclasse de &lt;code>Grafico&lt;/code>, servindo para representar &lt;em>círculos&lt;/em>. Num nível básico, um &lt;em>círculo&lt;/em> é definido por um &lt;em>ponto&lt;/em> central e por um &lt;em>raio&lt;/em>. Contudo, para que exista uniformidade no posicionamento das formas representadas pelas várias subclasses de &lt;code>Grafico&lt;/code>, os círculos são também posicionados usando o canto superior esquerdo (de um &lt;em>quadrado imaginário&lt;/em> que o contenha), em vez do seu centro &amp;mdash; assim, o &lt;em>raio&lt;/em> é somado ao &lt;em>x&lt;/em> e ao &lt;em>y&lt;/em> para fazer as devidas compensações de posicionamento, determinando o &lt;em>centro&lt;/em>.
 * @property {number} x Abscissa para posicionar o &lt;em>círculo&lt;/em> no &lt;code>canvas&lt;/code>
 * @property {number} y Ordenada para posicionar o &lt;em>círculo&lt;/em> no &lt;code>canvas&lt;/code>
 * @property {number} raio Raio do &lt;em>círculo&lt;/em>
 * @property {string} preenchimento Cor ou padrão do preenchimento &lt;em>círculo&lt;/em> &amp;mdash; se for &lt;code>null&lt;/code>, o &lt;em>círculo&lt;/em> não é preenchido
 * @property {string} contorno Cor ou padrão do contorno do &lt;em>círculo&lt;/em> &amp;mdash; se for &lt;code>null&lt;/code>, o contorno não é desenhado
 * @property {number} espessura Espessura do contorno do &lt;em>círculo&lt;/em> &amp;mdash; se a espessura tiver um valor igual ou inferior a zero (&lt;code>0&lt;/code>), o contorno não é desenhado
 * @property {number} deltaX=0 Variação horizontal da posição do &lt;em>círculo&lt;/em>
 * @property {number} deltaY=0 Variação vertical da posição do &lt;em>círculo&lt;/em>
 * @property {number} distX=0 Distância horizontal até um dado ponto &amp;mdash; pode ser usada, por exemplo, para guardar o &lt;em>offset&lt;/em> do &lt;em>x&lt;/em> em relação à posição &lt;em>x&lt;/em> do cursor do rato
 * @property {number} distY=0 Distância vertical até um dado ponto &amp;mdash; pode ser usada, por exemplo, para guardar o &lt;em>offset&lt;/em> do &lt;em>y&lt;/em> em relação à posição &lt;em>y&lt;/em> do cursor do rato
 * @property {number} angulo=0 Ângulo de rotação do &lt;em>círculo&lt;/em> quando desenhado no &lt;code>canvas&lt;/code> &amp;mdash; dadas as características do &lt;em>círculo&lt;/em>, esta propriedade é ignorada no seu desenho no &lt;code>canvas&lt;/code>
 * @property {number} gravidade=0 Força que, quando usada em conjunto com o &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação vertical do &lt;em>cículo&lt;/em>, actuando como a &lt;em>gravidade&lt;/em>
 * @property {number} velocidade=0 Velocidade que, quando usada em conjunto com o &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação horizontal e vertical do &lt;em>círculo&lt;/em>
 * @property {boolean} activo=true Indicação de que o &lt;em>círculo&lt;/em> deve testar colisões, quando chamado o método &lt;code>colide(outro)&lt;/code>
 * @property {boolean} rotacao=false Indicação de que o &lt;em>círculo&lt;/em> deve rodar, reflectindo o seu &lt;em>ângulo&lt;/em> &amp;mdash; dadas as características do &lt;em>círculo&lt;/em>, esta propriedade é ignorada no seu desenho no &lt;code>canvas&lt;/code>
 * @property {boolean} visivel=true Indicação de que o &lt;em>círculo&lt;/em> deve ser desenhado no &lt;code>canvas&lt;/code>, quando chamado o método &lt;code>desenha(tela)&lt;/code>
 */
class Circulo extends Grafico {
  /**
   * Construtor para criação de novos objectos do tipo &lt;code>Círculo&lt;/code>
   * @param {number} x Abscissa para posicionar o &lt;em>círculo&lt;/em> no &lt;code>canvas&lt;/code>
   * @param {number} y Ordenada para posicionar o &lt;em>círculo&lt;/em> no &lt;code>canvas&lt;/code>
   * @param {number} raio Raio do &lt;em>círculo&lt;/em>
   * @param {string} preenchimento="black" Cor ou padrão do preenchimento do &lt;em>círculo&lt;/em>
   * @param {string} contorno="black" Cor ou padrão do contorno do &lt;em>círculo&lt;/em>
   * @param {number} espessura=0 Espessura do contorno do &lt;em>círculo&lt;/em>
   */
  constructor(x, y, raio, preenchimento = "black", contorno = "black", espessura = 0) {
    super(x, y);
    this.raio = raio;
    this.preenchimento = preenchimento;
    this.contorno = contorno;
    this.espessura = espessura;
  }

  /**
   * Conjunto de pontos que delimitam o &lt;em>círculo&lt;/em>, definindo um &lt;em>envelope&lt;/em> &amp;mdash; são usados, arbitrariamente, &lt;em>36&lt;/em> pontos igualmente espaçados sobre a circunferência
   * @type {array}
   */
  get envelope() {
    var envelope = new Array(36);
    for (var i = 0; i &lt; envelope.length; i++) {
      envelope[i] = { x: this.raio + this.raio * Math.cos(2 * Math.PI * i / envelope.length + Math.PI) + this.x, y: this.raio + this.raio * Math.sin(2 * Math.PI * i / envelope.length + Math.PI) + this.y };
    }
    return envelope;
  }

  /**
   * Largura do menor &lt;em>quadrado imaginário&lt;/em> que envolva este &lt;em>círculo&lt;/em> &amp;mdash; na prática, corresponde ao diâmetro
   * @type {number}
   */
  get largura() {
    return this.raio * 2;
  }

  /**
   * Altura do menor &lt;em>quadrado imaginário&lt;/em> que envolva este &lt;em>círculo&lt;/em> &amp;mdash; na prática, corresponde ao diâmetro
   * @type {number}
   */
  get altura() {
    return this.raio * 2;
  }

  /**
   * Este método verifica se um dado &lt;em>ponto&lt;/em> está contido na área deste &lt;em>círculo&lt;/em>. Tal acontece quando a distância desse &lt;em>ponto&lt;/em> ao centro do &lt;em>círculo&lt;/em> é inferior ao &lt;em>raio&lt;/em> do &lt;em>círculo&lt;/em>.
   * @param {number} x Abscissa do ponto a testar se está contido neste &lt;em>círculo&lt;/em>
   * @param {number} y Ordenada do ponto a testar se está contido neste &lt;em>círculo&lt;/em>
   * @returns {boolean} Se o ponto estiver contido neste &lt;em>círculo&lt;/em>, &lt;code>true&lt;/code>; senão, &lt;code>false&lt;/code>
   */
  contemPonto(x, y) {
    return (Math.hypot((this.x + this.raio) - x, (this.y + this.raio) - y) &lt; this.raio);
  }

  /**
   * Este método desenha um &lt;em>círculo&lt;/em> no &lt;code>canvas&lt;/code>, usando como referência de posicionamento o &lt;em>ponto&lt;/em> correspondente ao canto superior esquerdo do menor &lt;em>quadrado imaginário&lt;/em> que envolva o &lt;em>círculo&lt;/em>.
   * @param {Tela} tela Objecto que representa o elemento &lt;code>canvas&lt;/code> onde será desenhado o &lt;em>círculo&lt;/em>
   */
  desenha(tela) {
    this.x += this.distX;
    this.y += this.distY;
    if (this.visivel) {
      var contexto = tela.contexto;
      contexto.save();
      contexto.beginPath();
      // para evitar processamento desnecessário, só se faz a translação e a rotação do canvas quando o ângulo é diferente de zero (0), já que, quando o ângulo tem esse valor, o resultado é idêntico a quando não se faz qualquer rotação
      if (this.rotacao &amp;&amp; this.angulo != 0) {
        contexto.translate(Math.floor(this.x + this.centroide.x), Math.floor(this.y + this.centroide.y));
        contexto.rotate(this.angulo * Math.PI / 180);
        contexto.arc(Math.floor(-this.centroide.x + this.raio), Math.floor(-this.centroide.y + this.raio), this.raio, 0, Math.PI * 2);
      }
      else {
        contexto.arc(Math.floor(this.x + this.raio), Math.floor(this.y + this.raio), this.raio, 0, Math.PI * 2);
      }
      contexto.arc(Math.floor(this.x + this.raio), Math.floor(this.y + this.raio), this.raio, 0, Math.PI * 2);
      contexto.closePath();
      contexto.fillStyle = this.preenchimento;
      contexto.strokeStyle = this.contorno;
      contexto.lineWidth = this.espessura;
      if (this.preenchimento != null) {
        contexto.fill();
      }
      if ((this.contorno != null) &amp;&amp; (this.espessura > 0)) {
        contexto.stroke();
      }
      contexto.restore();
    }
    this.x += this.deltaX + this.velocidade * Math.cos(this.angulo * Math.PI / 180);
    this.y += this.deltaY + this.velocidade * Math.sin(this.angulo * Math.PI / 180) + this.gravidade * Math.cos(this.angulo * Math.PI / 180);
  }
}

//

/**
 * @class
 * @extends Grafico
 * @classdesc A classe &lt;code>Rectangulo&lt;/code> é uma subclasse de &lt;code>Grafico&lt;/code>, servindo para representar &lt;em>rectângulos&lt;/em>. Num nível básico, um &lt;em>rectângulo&lt;/em> é definido por um &lt;em>ponto&lt;/em>, correspondente, regra geral, ao seu canto superior esquerdo e por uma &lt;em>largura&lt;/em> e por uma &lt;em>altura&lt;/em>.
 * @property {number} x Abscissa para posicionar o &lt;em>rectângulo&lt;/em> no &lt;code>canvas&lt;/code>
 * @property {number} y Ordenada para posicionar o &lt;em>rectângulo&lt;/em> no &lt;code>canvas&lt;/code>
 * @property {string} preenchimento Cor ou padrão do preenchimento &lt;em>rectângulo&lt;/em> &amp;mdash; se for &lt;code>null&lt;/code>, o &lt;em>rectângulo&lt;/em> não é preenchido
 * @property {string} contorno Cor ou padrão do contorno do &lt;em>rectângulo&lt;/em> &amp;mdash; se for &lt;code>null&lt;/code>, o contorno não é desenhado
 * @property {number} espessura Espessura do contorno do &lt;em>rectângulo&lt;/em> &amp;mdash; se a espessura tiver um valor igual ou inferior a zero (&lt;code>0&lt;/code>), o contorno não é desenhado
 * @property {number} deltaX=0 Variação horizontal da posição do &lt;em>rectângulo&lt;/em>
 * @property {number} deltaY=0 Variação vertical da posição do &lt;em>rectângulo&lt;/em>
 * @property {number} distX=0 Distância horizontal até um dado ponto &amp;mdash; pode ser usada, por exemplo, para guardar o &lt;em>offset&lt;/em> do &lt;em>x&lt;/em> em relação à posição &lt;em>x&lt;/em> do cursor do rato
 * @property {number} distY=0 Distância vertical até um dado ponto &amp;mdash; pode ser usada, por exemplo, para guardar o &lt;em>offset&lt;/em> do &lt;em>y&lt;/em> em relação à posição &lt;em>y&lt;/em> do cursor do rato
 * @property {number} angulo=0 Ângulo de rotação do &lt;em>rectângulo&lt;/em> quando desenhado no &lt;code>canvas&lt;/code> &amp;mdash; a rotação é feita tendo como referência o centro do &lt;em>rectângulo&lt;/em>
 * @property {number} gravidade=0 Força que, quando usada em conjunto com o &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação vertical do &lt;em>rectângulo&lt;/em>, actuando como a &lt;em>gravidade&lt;/em>
 * @property {number} velocidade=0 Velocidade que, quando usada em conjunto com o &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação horizontal e vertical do &lt;em>rectângulo&lt;/em>
 * @property {boolean} activo=true Indicação de que o &lt;em>rectângulo&lt;/em> deve testar colisões, quando chamado o método &lt;code>colide(outro)&lt;/code>
 * @property {boolean} rotacao=false Indicação de que o &lt;em>rectângulo&lt;/em> deve rodar, reflectindo o seu &lt;em>ângulo&lt;/em>
 * @property {boolean} visivel=true Indicação de que o &lt;em>rectângulo&lt;/em> deve ser desenhado no &lt;code>canvas&lt;/code>, quando chamado o método &lt;code>desenha(tela)&lt;/code>
  */
class Rectangulo extends Grafico {
  #largura;
  #altura;

  /**
   * Construtor para criação de novos objectos do tipo &lt;code>Rectangulo&lt;/code>
   * @param {number} x Abscissa para posicionar o &lt;em>rectângulo&lt;/em> no &lt;code>canvas&lt;/code>
   * @param {number} y Ordenada para posicionar o &lt;em>rectângulo&lt;/em> no &lt;code>canvas&lt;/code>
   * @param {number} largura Largura do &lt;em>rectângulo&lt;/em>
   * @param {number} altura Altura do &lt;em>rectângulo&lt;/em>
   * @param {string} preenchimento="black" Cor ou padrão do preenchimento do &lt;em>rectângulo&lt;/em>
   * @param {string} contorno="black" Cor ou padrão do contorno do &lt;em>rectângulo&lt;/em>
   * @param {number} espessura=0 Espessura do contorno do &lt;em>rectângulo&lt;/em>
   */
  constructor(x, y, largura, altura, preenchimento = "black", contorno = "black", espessura = 0) {
    super(x, y);
    this.#largura = largura;
    this.#altura = altura;
    this.preenchimento = preenchimento;
    this.contorno = contorno;
    this.espessura = espessura;
  }

  /**
   * Largura do &lt;em>rectângulo&lt;/em> &lt;em>[definição]&lt;/em>
   * @type {number}
   */
  set largura(largura) {
    this.#largura = largura;
  }

  /**
   * Largura do &lt;em>rectângulo&lt;/em> &lt;em>[obtenção]&lt;/em>
   * @type {number}
   */
  get largura() {
    return this.#largura;
  }

  /**
   * Altura do &lt;em>rectângulo&lt;/em> &lt;em>[definição]&lt;/em>
   * @type {number}
   */
  set altura(altura) {
    this.#altura = altura;
  }

  /**
   * Altura do &lt;em>rectângulo&lt;/em> &lt;em>[obtenção]&lt;/em>
   * @type {number}
   */
  get altura() {
    return this.#altura;
  }

  /**
   * Este método desenha um &lt;em>rectângulo&lt;/em> no &lt;code>canvas&lt;/code>, usando como referência de posicionamento o &lt;em>ponto&lt;/em> correspondente ao canto superior esquerdo desse &lt;em>rectângulo&lt;/em>.
   * @param {Tela} tela Objecto que representa o elemento &lt;code>canvas&lt;/code> onde será desenhado o &lt;em>rectângulo&lt;/em>
   */
  desenha(tela) {
    this.x += this.distX;
    this.y += this.distY;
    if (this.visivel) {
      var contexto = tela.contexto;
      contexto.save();
      contexto.beginPath();
      // para evitar processamento desnecessário, só se faz a translação e a rotação do canvas quando o ângulo é diferente de zero (0), já que, quando o ângulo tem esse valor, o resultado é idêntico a quando não se faz qualquer rotação
      if (this.rotacao &amp;&amp; this.angulo != 0) {
        contexto.translate(Math.floor(this.x + this.centroide.x), Math.floor(this.y + this.centroide.y));
        contexto.rotate(this.angulo * Math.PI / 180);
        contexto.rect(Math.floor(-this.centroide.x), Math.floor(-this.centroide.y), this.largura, this.altura);
      }
      else {
        contexto.rect(Math.floor(this.x), Math.floor(this.y), this.largura, this.altura);
      }
      contexto.closePath();
      contexto.fillStyle = this.preenchimento;
      contexto.strokeStyle = this.contorno;
      contexto.lineWidth = this.espessura;
      if (this.preenchimento != null) {
        contexto.fill();
      }
      if ((this.contorno != null) &amp;&amp; (this.espessura > 0)) {
        contexto.stroke();
      }
      contexto.restore();
    }
    this.x += this.deltaX + this.velocidade * Math.cos(this.angulo * Math.PI / 180);
    this.y += this.deltaY + this.velocidade * Math.sin(this.angulo * Math.PI / 180) + this.gravidade * Math.cos(this.angulo * Math.PI / 180);
  }
}

//

/**
 * @class
 * @extends Grafico
 * @classdesc A classe &lt;code>Poligono&lt;/code> é uma subclasse de &lt;code>Grafico&lt;/code>, servindo para representar &lt;em>polígonos&lt;/em>. Num nível básico, um &lt;em>polígono&lt;/em> é definido por um &lt;em>ponto&lt;/em>, correspondente, regra geral, ao canto superior esquerdo de um &lt;em>rectângulo imaginário&lt;/em> que contenha o &lt;em>polígono&lt;/em>. Assim, este será o &lt;em>ponto&lt;/em> relativamente ao qual todos os pontos do &lt;em>polígono&lt;/em> serão posicionados. Aconselha-se que todos os pontos do polígono se encontrem à direita e abaixo desta origem e tão próximos dela quanto possível; caso contrário, aspectos como a rotação do polígono poderão ter resultados diferentes do esperado. Deste modo, há a possibilidade, activada por omissão através do atributo &lt;code>ajuste&lt;/code>, de &lt;em>encostar&lt;/em> o polígono à origem &amp;mdash; contudo, tal implica a alteração (o referido &lt;em>ajuste&lt;/em>) de todos os pontos.
 * @property {number} x Abscissa para posicionar o &lt;em>polígono&lt;/em> no &lt;code>canvas&lt;/code>
 * @property {number} y Ordenada para posicionar o &lt;em>polígono&lt;/em> no &lt;code>canvas&lt;/code>
 * @property {array} vertices Conjunto de pontos com os vários vértices do &lt;em>polígono&lt;/em>
 * @property {string} preenchimento Cor ou padrão do preenchimento &lt;em>polígono&lt;/em> &amp;mdash; se for &lt;code>null&lt;/code>, o &lt;em>polígono&lt;/em> não é preenchido
 * @property {string} contorno Cor ou padrão do contorno do &lt;em>polígono&lt;/em> &amp;mdash; se for &lt;code>null&lt;/code>, o contorno não é desenhado
 * @property {number} espessura Espessura do contorno do &lt;em>polígono&lt;/em> &amp;mdash; se a espessura tiver um valor igual ou inferior a zero (&lt;code>0&lt;/code>), o contorno não é desenhado
 * @property {number} deltaX=0 Variação horizontal da posição do &lt;em>polígono&lt;/em>
 * @property {number} deltaY=0 Variação vertical da posição do &lt;em>polígono&lt;/em>
 * @property {number} distX=0 Distância horizontal até um dado ponto &amp;mdash; pode ser usada, por exemplo, para guardar o &lt;em>offset&lt;/em> do &lt;em>x&lt;/em> em relação à posição &lt;em>x&lt;/em> do cursor do rato
 * @property {number} distY=0 Distância vertical até um dado ponto &amp;mdash; pode ser usada, por exemplo, para guardar o &lt;em>offset&lt;/em> do &lt;em>y&lt;/em> em relação à posição &lt;em>y&lt;/em> do cursor do rato
 * @property {number} deslocX=0 Deslocamento horizontal do ponto mais à esquerda do polígono até ponto usado para posicionar o &lt;em>polígono&lt;/em>, quando se fez o ajuste posicional do polígono &amp;mdash; se o seu valor for zero (&lt;code>0&lt;/code>), não foi feito qualquer ajuste
 * @property {number} deslocY=0 Deslocamento vertical do ponto mais à esquerda do polígono até ponto usado para posicionar o &lt;em>polígono&lt;/em>, quando se fez o ajuste posicional do polígono &amp;mdash; se o seu valor for zero (&lt;code>0&lt;/code>), não foi feito qualquer ajuste
 * @property {number} angulo=0 Ângulo de rotação do &lt;em>polígono&lt;/em> quando desenhado no &lt;code>canvas&lt;/code> &amp;mdash; a rotação é feita tendo como referência o centro do &lt;em>polígono&lt;/em>
 * @property {number} gravidade=0 Força que, quando usada em conjunto com o &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação vertical do &lt;em>polígono&lt;/em>, actuando como a &lt;em>gravidade&lt;/em>
 * @property {number} velocidade=0 Velocidade que, quando usada em conjunto com o &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação horizontal e vertical do &lt;em>polígono&lt;/em>
 * @property {boolean} activo=true Indicação de que o &lt;em>polígono&lt;/em> deve testar colisões, quando chamado o método &lt;code>colide(outro)&lt;/code>
 * @property {boolean} rotacao=false Indicação de que o &lt;em>polígono&lt;/em> deve rodar, reflectindo o seu &lt;em>ângulo&lt;/em>
 * @property {boolean} visivel=true Indicação de que o &lt;em>polígono&lt;/em> deve ser desenhado no &lt;code>canvas&lt;/code>, quando chamado o método &lt;code>desenha(tela)&lt;/code>
 */
class Poligono extends Grafico {
  #justo;
  #vertices;

  /**
   * Construtor para criação de novos objectos do tipo &lt;code>Poligono&lt;/code>
   * @param {number} x Abscissa para posicionar o &lt;em>polígono&lt;/em> no &lt;code>canvas&lt;/code>
   * @param {number} y Ordenada para posicionar o &lt;em>polígono&lt;/em> no &lt;code>canvas&lt;/code>
   * @param {array} vertices Conjunto de pontos com os vários vértices do &lt;em>polígono&lt;/em>
   * @param {string} preenchimento="black" Cor ou padrão do preenchimento do &lt;em>polígono&lt;/em>
   * @param {string} contorno="black" Cor ou padrão do contorno do &lt;em>polígono&lt;/em>
   * @param {number} espessura=0 Espessura do contorno do &lt;em>polígono&lt;/em>
   * @param {boolean} justo=true Indicação de que o &lt;em>polígono&lt;/em> deve ser reposicionado de forma a ficar &lt;em>encostado&lt;/em> ao ponto usado para definir o seu posicionamento no &lt;code>canvas&lt;/code>
   */
  constructor(x, y, vertices, preenchimento = "black", contorno = "black", espessura = 0, justo = true) {
    super(x, y);
    this.#vertices = vertices;
    this.preenchimento = preenchimento;
    this.contorno = contorno;
    this.espessura = espessura;
    this.#justo = justo;
    //se ajuste for verdadeiro (true), todo os pontos são alterados de forma a que o polígono seja "encostado" à origem -- o ponto (x, y) do polígono
    if (this.#justo) {
      this.#ajusta();
    }
  }

  /**
   * Conjunto de pontos que delimitam o &lt;em>polígono&lt;/em>, definindo um &lt;em>envelope&lt;/em>
   * @type {array}
   */
  get envelope() {
    var verticesCartesianos = this.#vertices;
    var verticesPolares = new Array(verticesCartesianos.length);
    for (var i = 0; i &lt; verticesPolares.length; i++) {
      verticesPolares[i] = Utilitarios.calculaCoordenadasPolares(this.#vertices[i].x - this.centroide.x, this.#vertices[i].y - this.centroide.y);
    }
    var envelope = new Array(verticesPolares.length);
    for (var i = 0; i &lt; envelope.length; i++) {
      envelope[i] = { x: Utilitarios.calculaCoordenadasCartesianas(verticesPolares[i].distancia, verticesPolares[i].angulo + this.angulo).x + this.centroide.x + this.x, y: Utilitarios.calculaCoordenadasCartesianas(verticesPolares[i].distancia, verticesPolares[i].angulo + this.angulo).y + this.centroide.y + this.y };

    }
    return envelope;
  }

  // este método privado ajusta o polígono de forma a ficar encostado ao ponto usado para definir o seu posicionamento no canvas
  #ajusta() {
    var deslocX = Number.MAX_VALUE;
    var deslocY = Number.MAX_VALUE;
    for (var i = 0, j = this.#vertices.length - 1; i &lt; this.#vertices.length; j = i++) {
      deslocX = Math.min(deslocX, this.#vertices[i].x);
    }
    for (var i = 0, j = this.#vertices.length - 1; i &lt; this.#vertices.length; j = i++) {
      deslocY = Math.min(deslocY, this.#vertices[i].y);
    }
    for (var i = 0; i &lt; this.#vertices.length; i++) {
      this.#vertices[i].x -= deslocX;
      this.#vertices[i].y -= deslocY;
    }
  }

  /**
   * Conjunto de pontos com os vários vértices do &lt;em>polígono&lt;/em> &lt;em>[definição]&lt;/em>
   * @type {array}
   */
  set vertices(vertices) {
    this.#vertices = vertices;
    if (this.#justo) {
      this.#ajusta();
    }
    for (var i = 0; i &lt; this.#vertices.length; i++) {
      this.envelope.push({ x: this.#vertices[i].x, y: this.#vertices[i].y });
    }
  }

  /**
   * Conjunto de pontos com os vários vértices do &lt;em>polígono&lt;/em> &lt;em>[obtenção]&lt;/em>
   * @type {array}
   */
  get vertices() {
    return this.#vertices;
  }

  /**
   * Largura do menor &lt;em>rectângulo imaginário&lt;/em> que envolva este &lt;em>polígono&lt;/em> &amp;mdash; sendo definida pela distância entre o &lt;em>x&lt;/em> do ponto mais à esquerda e o &lt;em>x&lt;/em> do ponto mais à direita do &lt;em>polígono&lt;/em>
   * @type {number}
   */
  get largura() {
    var minX = Number.MAX_VALUE;
    var maxX = Number.MIN_VALUE;
    for (var i = 0, j = this.#vertices.length - 1; i &lt; this.#vertices.length; j = i++) {
      minX = Math.min(minX, this.#vertices[i].x);
      maxX = Math.max(maxX, this.#vertices[j].x);
    }
    return maxX - minX;
  }

  /**
   * Altura do menor &lt;em>rectângulo imaginário&lt;/em> que envolva este &lt;em>polígono&lt;/em> &amp;mdash; sendo definida pela distância entre o &lt;em>y&lt;/em> do ponto mais acima e o &lt;em>y&lt;/em> do ponto mais abaixo do &lt;em>polígono&lt;/em>
   * @type {number}
   */
  get altura() {
    var minY = Number.MAX_VALUE;
    var maxY = Number.MIN_VALUE;
    for (var i = 0, j = this.#vertices.length - 1; i &lt; this.#vertices.length; j = i++) {
      minY = Math.min(minY, this.#vertices[i].y);
      maxY = Math.max(maxY, this.#vertices[j].y);
    }
    return maxY - minY;
  }

  /**
   * Centróide do &lt;em>polígono&lt;/em> considerando os pontos dos seus vértices
   * @type {PontoCartesiano}
   */
  get centroide() {
    var somaX = 0;
    var somaY = 0;
    for (var i = 0; i &lt; this.#vertices.length; i++) {
      somaX += this.#vertices[i].x;
      somaY += this.#vertices[i].y;
    }
    var centroideX = Math.floor(somaX / this.#vertices.length);
    var centroideY = Math.floor(somaY / this.#vertices.length);
    return { x: centroideX, y: centroideY };
  }

  /**
   * Este método desenha um &lt;em>polígono&lt;/em> no &lt;code>canvas&lt;/code>, usando como referência de posicionamento o &lt;em>ponto&lt;/em> correspondente ao canto superior esquerdo de um &lt;em>rectângulo imaginário&lt;/em> que contenha o &lt;em>polígono&lt;/em>.
   * @param {Tela} tela Objecto que representa o elemento &lt;code>canvas&lt;/code> onde será desenhado o &lt;em>polígono&lt;/em>
   */
  desenha(tela) {
    this.x += this.distX;
    this.y += this.distY;
    if (this.visivel) {
      var contexto = tela.contexto;
      contexto.save();
      contexto.beginPath()
      // para evitar processamento desnecessário, só se faz a translação e a rotação quando o ângulo é diferente de zero (0), já que, quando o ângulo tem esse valor, o resultado é idêntico a quando não se faz qualquer rotação
      if (this.rotacao &amp;&amp; this.angulo != 0) {
        contexto.translate(Math.floor(this.x + this.centroide.x), Math.floor(this.y + this.centroide.y));
        contexto.rotate(this.angulo * Math.PI / 180);
        for (var i = 0; i &lt; this.#vertices.length; i++) {
          if (i == 0) {
            contexto.moveTo(Math.floor(this.#vertices[i].x - this.centroide.x), Math.floor(this.#vertices[i].y - this.centroide.y));
          }
          else {
            contexto.lineTo(Math.floor(this.#vertices[i].x - this.centroide.x), Math.floor(this.#vertices[i].y - this.centroide.y));
          }
        }
      }
      else {
        for (var i = 0; i &lt; this.#vertices.length; i++) {
          if (i == 0) {
            contexto.moveTo(Math.floor(this.#vertices[i].x + this.x), Math.floor(this.#vertices[i].y + this.y));
          }
          else {
            contexto.lineTo(Math.floor(this.#vertices[i].x + this.x), Math.floor(this.#vertices[i].y + this.y));
          }
        }
      }
      contexto.closePath();
      contexto.fillStyle = this.preenchimento;
      contexto.strokeStyle = this.contorno;
      contexto.lineWidth = this.espessura;
      if (this.preenchimento != null) {
        contexto.fill();
      }
      if ((this.contorno != null) &amp;&amp; (this.espessura > 0)) {
        contexto.stroke();
      }
      contexto.restore();
    }
    this.x += this.deltaX + this.velocidade * Math.cos(this.angulo * Math.PI / 180);
    this.y += this.deltaY + this.velocidade * Math.sin(this.angulo * Math.PI / 180) + this.gravidade * Math.cos(this.angulo * Math.PI / 180);
  }
}

//

/**
 * @class
 * @extends Grafico
 * @classdesc A classe &lt;code>Texto&lt;/code> é uma subclasse de &lt;code>Grafico&lt;/code>, servindo para representar uma &lt;em>(linha de) texto&lt;/em>.
 * @property {number} x Abscissa para posicionar o &lt;em>texto&lt;/em> no &lt;code>canvas&lt;/code>
 * @property {number} y Ordenada para posicionar o &lt;em>texto&lt;/em> no &lt;code>canvas&lt;/code>
 * @property {string} preenchimento Cor ou padrão do preenchimento do &lt;em>texto&lt;/em> &amp;mdash; se for &lt;code>null&lt;/code>, o &lt;em>texto&lt;/em> não é preenchido
 * @property {string} contorno Cor ou padrão do contorno do &lt;em>texto&lt;/em> &amp;mdash; se for &lt;code>null&lt;/code>, o contorno não é desenhado
 * @property {number} espessura Espessura do contorno do &lt;em>texto&lt;/em> &amp;mdash; se a espessura tiver um valor igual ou inferior a zero (&lt;code>0&lt;/code>), o contorno não é desenhado
 * @property {number} tamanho=16 Tamanho do &lt;em>texto&lt;/em> em pontos (&lt;code>pt&lt;/code)
 * @property {number} fonte="sans-serif" Fonte do &lt;em>texto&lt;/em>
 * @property {number} deltaX=0 Variação horizontal da posição do &lt;em>texto&lt;/em>
 * @property {number} deltaY=0 Variação vertical da posição do &lt;em>texto&lt;/em>
 * @property {number} distX=0 Distância horizontal até um dado ponto &amp;mdash; pode ser usada, por exemplo, para guardar o &lt;em>offset&lt;/em> do &lt;em>x&lt;/em> em relação à posição &lt;em>x&lt;/em> do cursor do rato
 * @property {number} distY=0 Distância vertical até um dado ponto &amp;mdash; pode ser usada, por exemplo, para guardar o &lt;em>offset&lt;/em> do &lt;em>y&lt;/em> em relação à posição &lt;em>y&lt;/em> do cursor do rato
 * @property {number} angulo=0 Ângulo de rotação do &lt;em>texto&lt;/em> quando desenhado no &lt;code>canvas&lt;/code> &amp;mdash; a rotação é feita tendo como referência o centro do &lt;em>texto&lt;/em>
 * @property {number} gravidade=0 Força que, quando usada em conjunto com o &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação vertical do &lt;em>texto&lt;/em>, actuando como a &lt;em>gravidade&lt;/em>
 * @property {number} velocidade=0 Velocidade que, quando usada em conjunto com o &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação horizontal e vertical do &lt;em>texto&lt;/em>
 * @property {boolean} activo=true Indicação de que o &lt;em>texto&lt;/em> deve testar colisões, quando chamado o método &lt;code>colide(outro)&lt;/code>
 * @property {boolean} rotacao=false Indicação de que o &lt;em>texto&lt;/em> deve rodar, reflectindo o seu &lt;em>ângulo&lt;/em>
 * @property {boolean} visivel=true Indicação de que o &lt;em>texto&lt;/em> deve ser desenhado no &lt;code>canvas&lt;/code>, quando chamado o método &lt;code>desenha(tela)&lt;/code>
 */
class Texto extends Grafico {
  /**
   * Construtor para criação de novos objectos do tipo &lt;code>Texto&lt;/code>
   * @param {number} x Abscissa para posicionar o &lt;em>texto&lt;/em> no &lt;code>canvas&lt;/code>
   * @param {number} y Ordenada para posicionar o &lt;em>texto&lt;/em> no &lt;code>canvas&lt;/code>
   * @param {string} texto Conteúdo de &lt;em>texto&lt;/em> a desenhar no &lt;code>canvas&lt;/code>
   * @param {string} preenchimento="black" Cor do preenchimento do &lt;em>texto&lt;/em>
   * @param {string} contorno="black" Cor ou padrão do contorno do &lt;em>texto&lt;/em>
   * @param {number} espessura=0 Espessura do contorno do &lt;em>texto&lt;/em>
   */
  constructor(x, y, texto, preenchimento = "black", contorno = "black", espessura = 0) {
    super(x, y);
    this.texto = texto;
    this.preenchimento = preenchimento;
    this.contorno = contorno;
    this.espessura = espessura;
    this.tamanho = 16;
    this.fonte = "sans-serif";
  }

  /**
   * Largura do &lt;em>texto&lt;/em> &amp;mdash; sendo definida pelos píxeis ocupados pelo texto horizontalmente
   * @type {number}
   */
  get largura() {
    var tela = document.createElement("canvas");
    var contexto = tela.getContext("2d");
    contexto.font = this.tamanho + "px " + this.fonte;
    return Math.floor(contexto.measureText(this.texto).width);
  }

  /**
   * Altura do &lt;em>texto&lt;/em> &amp;mdash; sendo definida pelo tamanho da fonte
   * @type {number}
   */
  get altura() {
    return this.tamanho;
  }

  /**
   * Este método desenha uma linha de &lt;em>texto&lt;/em> no &lt;code>canvas&lt;/code>, usando como referência de posicionamento o &lt;em>ponto&lt;/em> correspondente ao canto superior esquerdo de um &lt;em>rectângulo imaginário&lt;/em> que contenha o &lt;em>texto&lt;/em>.
   * @param {Tela} tela Objecto que representa o elemento &lt;code>canvas&lt;/code> onde será desenhado o &lt;em>texto&lt;/em>
   */
  desenha(tela) {
    this.x += this.distX;
    this.y += this.distY;
    if (this.visivel) {
      var contexto = tela.contexto;
      contexto.save();
      contexto.fillStyle = this.preenchimento;
      contexto.strokeStyle = this.contorno;
      contexto.lineWidth = this.espessura;
      contexto.textBaseline = "top";
      contexto.font = this.tamanho + "px " + this.fonte;
      contexto.fillStyle = this.preenchimento;
      // para evitar processamento desnecessário, só se faz a translação e a rotação quando o ângulo é diferente de zero (0), já que, quando o ângulo tem esse valor, o resultado é idêntico a quando não se faz qualquer rotação
      if (this.rotacao &amp;&amp; this.angulo != 0) {
        contexto.translate(Math.floor(this.x + this.largura * 0.5), Math.floor(this.y + this.altura * 0.5));
        contexto.rotate(this.angulo * Math.PI / 180);
        if (this.preenchimento != null) {
          contexto.fillText(this.texto, Math.floor(-this.largura * 0.5), Math.floor(-this.altura * 0.5));
        }
        if ((this.contorno != null) &amp;&amp; (this.espessura > 0)) {
          contexto.strokeText(this.texto, Math.floor(-this.largura * 0.5), Math.floor(-this.altura * 0.5));
        }
      }
      else {
        if (this.preenchimento != null) {
          contexto.fillText(this.texto, Math.floor(this.x), Math.floor(this.y));
        }
        if ((this.contorno != null) &amp;&amp; (this.espessura > 0)) {
          contexto.strokeText(this.texto, Math.floor(this.x), Math.floor(this.y));
        }
      }
      contexto.restore();
    }
    this.x += this.deltaX + this.velocidade * Math.cos(this.angulo * Math.PI / 180);
    this.y += this.deltaY + this.velocidade * Math.sin(this.angulo * Math.PI / 180) + this.gravidade * Math.cos(this.angulo * Math.PI / 180);
  }
}

//

/**
 * @class
 * @extends Grafico
 * @classdesc A classe &lt;code>Imagem&lt;/code> é uma subclasse de &lt;code>Grafico&lt;/code>, servindo para representar &lt;em>imagens&lt;/em>. Num nível básico, uma &lt;em>imagem&lt;/em> é definida por um &lt;em>ponto&lt;/em>, correspondente, regra geral, ao seu canto superior esquerdo e pela própria imagem.
 * @property {number} x Abscissa para posicionar a &lt;em>imagem&lt;/em> no &lt;code>canvas&lt;/code>
 * @property {number} y Ordenada para posicionar a &lt;em>imagem&lt;/em> no &lt;code>canvas&lt;/code>
 * @property {HTMLElement} imagem Elemento HTML que contém a &lt;em>imagem&lt;/em>
 * @property {number} largura Largura da &lt;em>imagem&lt;/em>
 * @property {number} altura Altura da &lt;em>imagem&lt;/em>
 * @property {number} deltaX=0 Variação horizontal da posição da &lt;em>imagem&lt;/em>
 * @property {number} deltaY=0 Variação vertical da posição da &lt;em>imagem&lt;/em>
 * @property {number} distX=0 Distância horizontal até um dado ponto &amp;mdash; pode ser usada, por exemplo, para guardar o &lt;em>offset&lt;/em> do &lt;em>x&lt;/em> em relação à posição &lt;em>x&lt;/em> do cursor do rato
 * @property {number} distY=0 Distância vertical até um dado ponto &amp;mdash; pode ser usada, por exemplo, para guardar o &lt;em>offset&lt;/em> do &lt;em>y&lt;/em> em relação à posição &lt;em>y&lt;/em> do cursor do rato
 * @property {number} angulo=0 Ângulo de rotação da &lt;em>imagem&lt;/em> quando desenhado no &lt;code>canvas&lt;/code> &amp;mdash; a rotação é feita tendo como referência o centro da &lt;em>imagem&lt;/em>
 * @property {number} gravidade=0 Força que, quando usada em conjunto com o &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação vertical da &lt;em>imagem&lt;/em>, actuando como a &lt;em>gravidade&lt;/em>
 * @property {number} velocidade=0 Velocidade que, quando usada em conjunto com o &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação horizontal e vertical da &lt;em>imagem&lt;/em>
tendo como referência o centro da &lt;em>imagem&lt;/em>
 * @property {boolean} activo=true Indicação de que a &lt;em>imagem&lt;/em> deve testar colisões, quando chamado o método &lt;code>colide(outro)&lt;/code>
 * @property {boolean} rotacao=false Indicação de que a &lt;em>imagem&lt;/em> deve rodar, reflectindo o seu &lt;em>ângulo&lt;/em>
 * @property {boolean} visivel=true Indicação de que a &lt;em>imagem&lt;/em> deve ser desenhada no &lt;code>canvas&lt;/code>, quando chamado o método &lt;code>desenha(tela)&lt;/code>
  */
class Imagem extends Grafico {
  /**
   * Construtor para criação de novos objectos do tipo &lt;code>Imagem&lt;/code>
   * @param {number} x Abscissa para posicionar a &lt;em>imagem&lt;/em> no &lt;code>canvas&lt;/code>
   * @param {number} y Ordenada para posicionar a &lt;em>imagem&lt;/em> no &lt;code>canvas&lt;/code>
   * @param {HTMLElement} imagem Elemento HTML que contém a &lt;em>imagem&lt;/em>
   */
  constructor(x, y, imagem) {
    super(x, y);
    this.imagem = imagem;
  }

  /**
   * Largura da &lt;em>imagem&lt;/em>
   * @type {number}
   */
  get largura() {
    return this.imagem.width;
  }

  /**
   * Altura da &lt;em>imagem&lt;/em>
   * @type {number}
   */
  get altura() {
    return this.imagem.height;
  }

  /**
   * Este método desenha uma &lt;em>imagem&lt;/em> no &lt;code>canvas&lt;/code>, usando como referência de posicionamento o &lt;em>ponto&lt;/em> correspondente ao canto superior esquerdo dessa &lt;em>imagem&lt;/em>.
   * @param {Tela} tela Objecto que representa o elemento &lt;code>canvas&lt;/code> onde será desenhada a &lt;em>imagem&lt;/em>
   */
  desenha(tela) {
    this.x += this.distX;
    this.y += this.distY;
    if (this.visivel) {
      var contexto = tela.contexto;
      // para evitar processamento desnecessário, só se faz a translação e a rotação quando o ângulo é diferente de zero (0), já que, quando o ângulo tem esse valor, o resultado é idêntico a quando não se faz qualquer rotação
      if (this.rotacao &amp;&amp; this.angulo != 0) {
        contexto.save();
        contexto.translate(Math.floor(this.x + this.largura * 0.5), Math.floor(this.y + this.altura * 0.5));
        contexto.rotate(this.angulo * Math.PI / 180);
        contexto.drawImage(this.imagem, Math.floor(-this.largura * 0.5), Math.floor(-this.altura * 0.5));
        contexto.restore();
      }
      else {
        contexto.drawImage(this.imagem, Math.floor(this.x), Math.floor(this.y));
      }
    }
    this.x += this.deltaX + this.velocidade * Math.cos(this.angulo * Math.PI / 180);
    this.y += this.deltaY + this.velocidade * Math.sin(this.angulo * Math.PI / 180) + this.gravidade * Math.cos(this.angulo * Math.PI / 180);
  }
}

//

/**
 * @class
 * @extends Grafico
 * @classdesc A classe &lt;code>ImagemAnimada&lt;/code> é uma subclasse de &lt;code>Grafico&lt;/code>, servindo para representar &lt;em>imagens animadas&lt;/em> (ou &lt;em>sprites&lt;/em>). Num nível básico, uma &lt;em>imagem animada&lt;/em> é definida por um &lt;em>ponto&lt;/em>, correspondente, regra geral, ao seu canto superior esquerdo, com os vários fotogramas a serem desenhados nessa posição, assumindo-se dimensões idênticas para cada um deles. Assim, os &lt;em>sprites&lt;/em> utilizados podem ter uma sequência horizontal (tira) ou várias, desde que os fotogramas tenham as mesmas dimensões.
 * @property {number} x Abscissa para posicionar o &lt;em>sprite&lt;/em> no &lt;code>canvas&lt;/code>
 * @property {number} y Ordenada para posicionar o &lt;em>sprite&lt;/em> no &lt;code>canvas&lt;/code>
 * @property {HTMLElement} imagem Elemento HTML que contém o &lt;em>sprite&lt;/em>
 * @property {number} fotogramas Número de fotogramas (&lt;em>frames&lt;/em>) do &lt;em>sprite&lt;/em>
 * @property {number} iteracoes Número de iterações &amp;mdash; na prática, o número de &lt;em>frames&lt;/em> a serem gerados por via do método &lt;code>window.requestAnimationFrame()&lt;/code> &amp;mdash; antes de se passar ao fotograma seguinte do &lt;em>sprite&lt;/em>
 * @property {number} contador=0 Número que vai registando o número de vezes que o &lt;em>sprite&lt;/em> foi desenhado, sendo necessário para controlar a transição entre fotogramas de fotogramas
 * @property {number} animado=true Indicação de que o &lt;em>sprite&lt;/em> deve ser desenhado &lt;em>animado&lt;/em> no &lt;code>canvas&lt;/code>, quando chamado o método &lt;code>desenha(tela)&lt;/code>; caso contrário, ficará parado num dos fotogramas
 * @property {number} indiceFotograma=0 Índice do fotograma a ser mostrado num dado momento; varia, de acordo como o número de &lt;em>iterações&lt;/em> definido, entre zero (&lt;code>0&lt;/code>) e o número de fotogramas existentes (&lt;em>exclusive&lt;/em>)
 * @property {number} indiceTira=0 Índice da tira de fotogramas a ser mostrada num dado momento; varia entre zero (&lt;code>0&lt;/code>) e o número de tiras existentes (&lt;em>exclusive&lt;/em>)
 * @property {number} tiras=1 Número de tiras existentes no &lt;em>sprite&lt;/em>
 * @property {number} largura Largura de um &lt;em>fotograma&lt;/em> do &lt;em>sprite&lt;/em>
 * @property {number} altura Altura de um &lt;em>fotograma&lt;/em> do &lt;em>sprite&lt;/em>
 * @property {number} deltaX=0 Variação horizontal da posição do &lt;em>sprite&lt;/em>
 * @property {number} deltaY=0 Variação vertical da posição do &lt;em>sprite&lt;/em>
 * @property {number} distX=0 Distância horizontal até um dado ponto &amp;mdash; pode ser usada, por exemplo, para guardar o &lt;em>offset&lt;/em> do &lt;em>x&lt;/em> em relação à posição &lt;em>x&lt;/em> do cursor do rato
 * @property {number} distY=0 Distância vertical até um dado ponto &amp;mdash; pode ser usada, por exemplo, para guardar o &lt;em>offset&lt;/em> do &lt;em>y&lt;/em> em relação à posição &lt;em>y&lt;/em> do cursor do rato
 * @property {number} angulo=0 Ângulo de rotação do &lt;em>sprite&lt;/em> quando desenhado no &lt;code>canvas&lt;/code> &amp;mdash; a rotação é feita tendo como referência o centro do &lt;em>sprite&lt;/em>
 * @property {number} gravidade=0 Força que, quando usada em conjunto com o &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação vertical do &lt;em>sprite&lt;/em>, actuando como a &lt;em>gravidade&lt;/em>
 * @property {number} velocidade=0 Velocidade que, quando usada em conjunto com o &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação horizontal e vertical do &lt;em>sprite&lt;/em>
 * @property {boolean} activo=true Indicação de que o &lt;em>sprite&lt;/em> deve testar colisões, quando chamado o método &lt;code>colide(outro)&lt;/code>
 * @property {boolean} rotacao=false Indicação de que o &lt;em>sprite&lt;/em> deve rodar, reflectindo o seu &lt;em>ângulo&lt;/em>
 * @property {boolean} visivel=true Indicação de que o &lt;em>sprite&lt;/em> deve ser desenhado no &lt;code>canvas&lt;/code>, quando chamado o método &lt;code>desenha(tela)&lt;/code>
*/
class ImagemAnimada extends Grafico {
  /**
   * Construtor para criação de novos objectos do tipo &lt;code>ImagemAnimada&lt;/code>
   * @param {number} x Abscissa para posicionar o &lt;em>sprite&lt;/em> no &lt;code>canvas&lt;/code>
   * @param {number} y Ordenada para posicionar o &lt;em>sprite&lt;/em> no &lt;code>canvas&lt;/code>
   * @param {HTMLElement} imagem Elemento HTML que contém o &lt;em>sprite&lt;/em>
   * @param {number} fotogramas Número de fotogramas (&lt;em>frames&lt;/em>) do &lt;em>sprite&lt;/em>
   * @param {number} iteracoes Número de iterações &amp;mdash; na prática, o número de &lt;em>frames&lt;/em> a serem gerados por via do método &lt;code>window.requestAnimationFrame()&lt;/code> &amp;mdash; antes de se passar ao fotograma seguinte do &lt;em>sprite&lt;/em>
   * @param {number} tiras=1 Número de tiras existentes no &lt;em>sprite&lt;/em>
   */
  constructor(x, y, imagem, fotogramas, iteracoes, tiras = 1) {
    super(x, y);
    this.imagem = imagem;
    this.fotogramas = fotogramas;
    this.iteracoes = iteracoes;
    this.contador = 0;
    this.animado = true;
    this.indiceFotograma = 0;
    this.indiceTira = 0;
    this.tiras = tiras;
  }

  /**
   * Altura da &lt;em>imagem animada&lt;/em>, considerando o número de tiras presentes e assumindo dimensões idênticas dos mesmos
   * @type {number}
   */
  get largura() {
    return this.imagem.width / this.fotogramas;
  }

  /**
   * Largura da &lt;em>imagem animada&lt;/em>, considerando o número de fotogramas presentes e assumindo dimensões idênticas dos mesmos
   * @type {number}
   */
  get altura() {
    return this.imagem.height / this.tiras;
  }

  /**
   * Este método desenha uma &lt;em>imagem animada&lt;/em> no &lt;code>canvas&lt;/code>, usando como referência de posicionamento o &lt;em>ponto&lt;/em> correspondente ao canto superior esquerdo dessa &lt;em>imagem animada&lt;/em>, no caso de uma única tira. Havendo mais que uma tira, usará o &lt;em>ponto&lt;/em> correspondente ao canto superior esquerdo dessa tira.
   * @param {Tela} tela Objecto que representa o elemento &lt;code>canvas&lt;/code> onde será desenhada a &lt;em>imagem animada&lt;/em>
   */
  desenha(tela) {
    this.x += this.distX;
    this.y += this.distY;
    if (this.visivel) {
      var contexto = tela.contexto;
      // para evitar processamento desnecessário, só se faz a translação e a rotação quando o ângulo é diferente de zero (0), já que, quando o ângulo tem esse valor, o resultado é idêntico a quando não se faz qualquer rotação
      if (this.rotacao &amp;&amp; this.angulo != 0) {
        contexto.save();
        contexto.translate(Math.floor(this.x + this.largura * 0.5), Math.floor(this.y + this.altura * 0.5));
        contexto.rotate(this.angulo * Math.PI / 180);
        contexto.drawImage(this.imagem, this.indiceFotograma * this.largura, this.indiceTira * this.altura, this.largura, this.altura, Math.floor(-this.largura * 0.5), Math.floor(-this.altura * 0.5), this.largura, this.altura);
        contexto.restore();
      }
      else {
        contexto.drawImage(this.imagem, this.indiceFotograma * this.largura, this.indiceTira * this.altura, this.largura, this.altura, Math.floor(this.x), Math.floor(this.y), this.largura, this.altura);
      }
      if ((this.animado) || (this.indiceFotograma > 0)) {
        if (this.contador % this.iteracoes == 0) {
          this.indiceFotograma++;
          if (this.indiceFotograma >= this.fotogramas) {
            this.indiceFotograma = 0;
          }
        }
        this.contador++;
      }
    }
    this.x += this.deltaX + this.velocidade * Math.cos(this.angulo * Math.PI / 180);
    this.y += this.deltaY + this.velocidade * Math.sin(this.angulo * Math.PI / 180) + this.gravidade * Math.cos(this.angulo * Math.PI / 180);
  }
}

//

/**
 * @class
 * @extends Grafico
 * @classdesc A classe &lt;code>ImagemFilme&lt;/code> é uma subclasse de &lt;code>Grafico&lt;/code>, servindo para representar &lt;em>filmes&lt;/em> (&lt;em>videos&lt;/em>) de forma embutida no &lt;code>canvas&lt;/code>. Num nível básico, uma &lt;em>imagem de filme&lt;/em> é definida por um &lt;em>ponto&lt;/em>, correspondente, regra geral, ao seu canto superior esquerdo e pela própria imagem &amp;mdash; isto é, o filme.
 * @property {number} x Abscissa para posicionar o &lt;em>filme&lt;/em> no &lt;code>canvas&lt;/code>
 * @property {number} y Ordenada para posicionar o &lt;em>filme&lt;/em> no &lt;code>canvas&lt;/code>
 * @property {Filme} filme Objecto de &lt;em>vídeo&lt;/em> a ser desenhado no &lt;code>canvas&lt;/code>
 * @property {number} y Ordenada para posicionar o &lt;em>filme&lt;/em> no &lt;code>canvas&lt;/code>
 * @property {number} altura Altura do &lt;em>filme&lt;/em> (&lt;em>vídeo&lt;/em>)
 * @property {number} deltaX=0 Variação horizontal da posição do &lt;em>filme&lt;/em>
 * @property {number} deltaY=0 Variação vertical da posição do &lt;em>filme&lt;/em>
 * @property {number} distX=0 Distância horizontal até um dado ponto &amp;mdash; pode ser usada, por exemplo, para guardar o &lt;em>offset&lt;/em> do &lt;em>x&lt;/em> em relação à posição &lt;em>x&lt;/em> do cursor do rato
 * @property {number} distY=0 Distância vertical até um dado ponto &amp;mdash; pode ser usada, por exemplo, para guardar o &lt;em>offset&lt;/em> do &lt;em>y&lt;/em> em relação à posição &lt;em>y&lt;/em> do cursor do rato
 * @property {number} angulo=0 Ângulo de rotação do &lt;em>filme&lt;/em> quando desenhado no &lt;code>canvas&lt;/code> &amp;mdash; a rotação é feita tendo como referência o centro do &lt;em>filme&lt;/em>
 * @property {number} gravidade=0 Força que, quando usada em conjunto com o &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação vertical do &lt;em>filme&lt;/em>, actuando como a &lt;em>gravidade&lt;/em>
 * @property {number} velocidade=0 Velocidade que, quando usada em conjunto com o &lt;em>ângulo&lt;/em>, pode ser utilizada para definir a variação horizontal e vertical do &lt;em>filme&lt;/em>
 * @property {boolean} activo=true Indicação de que o &lt;em>filme&lt;/em> deve testar colisões, quando chamado o método &lt;code>colide(outro)&lt;/code>
 * @property {boolean} rotacao=false Indicação de que o &lt;em>filme&lt;/em> deve rodar, reflectindo o seu &lt;em>ângulo&lt;/em>
 * @property {boolean} visivel=true Indicação de que o &lt;em>filme&lt;/em> deve ser desenhado no &lt;code>canvas&lt;/code>, quando chamado o método &lt;code>desenha(tela)&lt;/code>
*/
class ImagemFilme extends Grafico {
  /**
   * Construtor para criação de novos objectos do tipo &lt;code>ImagemFilme&lt;/code>
   * @param {number} x Abscissa para posicionar o &lt;em>filme&lt;/em> no &lt;code>canvas&lt;/code>
   * @param {number} y Ordenada para posicionar o &lt;em>filme&lt;/em> no &lt;code>canvas&lt;/code>
   * @param {Filme} filme Objecto que representa o elemento &lt;code>canvas&lt;/code> onde será desenhada o &lt;em>filme&lt;/em>
   */
  constructor(x, y, filme) {
    super(x, y);
    this.filme = filme;
  }

  /**
   * Altura do &lt;em>filme&lt;/em> (&lt;em>vídeo&lt;/em>)
   * @type {number}
   */
  get largura() {
    return this.filme.largura;
  }

  /**
   * Largura do &lt;em>filme&lt;/em> (&lt;em>vídeo&lt;/em>)
   * @type {number}
   */
  get altura() {
    return this.filme.altura;
  }

  /**
   * Este método desenha um &lt;code>video&lt;/code> no &lt;code>canvas&lt;/code>, usando como referência de posicionamento o &lt;em>ponto&lt;/em> correspondente ao canto superior esquerdo desse &lt;em>vídeo&lt;/em>. Note-se que o &lt;em>vídeo&lt;/em> só é efetivamente reproduzido no &lt;code>canvas&lt;/code> se o elemento &lt;code>video&lt;/code> associado por via da propriedade &lt;code>filme&lt;/code> estiver também a ser reproduzido.
   * @param {Tela} tela Objecto que representa o elemento &lt;code>canvas&lt;/code> onde será desenhada o &lt;em>vídeo&lt;/em>
   */
  desenha(tela) {
    this.x += this.distX;
    this.y += this.distY;
    if (this.visivel) {
      var contexto = tela.contexto;
      // para evitar processamento desnecessário, só se faz a translação e a rotação quando o ângulo é diferente de zero (0), já que, quando o ângulo tem esse valor, o resultado é idêntico a quando não se faz qualquer rotação
      if (this.rotacao &amp;&amp; this.angulo != 0) {
        contexto.save();
        contexto.translate(Math.floor(this.x + this.largura * 0.5), Math.floor(this.y + this.altura * 0.5));
        contexto.rotate(this.angulo * Math.PI / 180);
        contexto.drawImage(this.filme.elemento, Math.floor(-this.largura * 0.5), Math.floor(-this.altura * 0.5));
        contexto.restore();
      }
      else {
        contexto.drawImage(this.filme.elemento, Math.floor(this.x), Math.floor(this.y));
      }
    }
    this.x += this.deltaX + this.velocidade * Math.cos(this.angulo * Math.PI / 180);
    this.y += this.deltaY + this.velocidade * Math.sin(this.angulo * Math.PI / 180) + this.gravidade * Math.cos(this.angulo * Math.PI / 180);
  }
}

//

/**
 * @class
 * @classdesc A classe &lt;code>Tela&lt;/code> serve essencialmente como um envelope (&lt;em>wrapper&lt;/em>) para elementos de &lt;code>canvas&lt;/code>.
 * @property {HTMLElement} elemento O &lt;em>elemento&lt;/em> HTML do tipo &lt;code>canvas&lt;/code> a ser representado
 */
class Tela {
  #ratoX;
  #ratoY;

  /**
   * Construtor da classe &lt;code>Tela&lt;/code>.
   * @param {HTMLElement} elemento O &lt;em>elemento&lt;/em> HTML do tipo &lt;code>canvas&lt;/code> a ser representado
   */
  constructor(elemento) {
    this.elemento = elemento;
    this.#ratoX = 0;
    this.#ratoY = 0;
    this.codigoTecla = null;
    this.elemento.onclick = this.#processaRato.bind(this);
    this.elemento.onmousedown = this.#processaRato.bind(this);
    this.elemento.onmousemove = this.#processaRato.bind(this);
    this.elemento.onmouseup = this.#processaRato.bind(this);
    window.onkeydown = this.#processaTeclado.bind(this);
    window.onkeyup = this.#processaTeclado.bind(this);
  }

  #processaRato(evento) {
    this.ratoX = evento.offsetX;
    this.ratoY = evento.offsetY;
    switch (evento.type) {
      case 'click':
        this.processaClique();
        break;
      case 'mousedown':
        this.processaRatoDescido();
        break;
      case 'mousemove':
        this.processaRatoMovido();
        break;
      case 'mouseup':
        this.processaRatoSubido();
        break;
      default:
        break;
    }
  }

  #processaTeclado(evento) {
    this.codigoTecla = evento.code;
    switch (evento.type) {
      case 'keydown':
        this.processaTeclaDescida();
        break;
      case 'keyup':
        this.processaTeclaSubida();
        break;
      default:
        break;
    }
    this.codigoTecla = null;
  }

  /**
   * Propriedade correspondente ao &lt;em>evento&lt;/em> &lt;code>click&lt;/code>, a ser posteriormente definida como uma &lt;em>função&lt;/em> contendo as intruções a executar decorrentes desse evento, utilizando, se necessário, as propriedades &lt;code>ratoX&lt;/code> e &lt;code>ratoY&lt;/code>, associadas às coordenadas do &lt;em>rato&lt;/em> na &lt;em>tela&lt;/em>, já previamente obtidas e prontas a ser usadas
   * @type {function}
   */
  processaClique = function () { };

  /**
   * Propriedade correspondente ao &lt;em>evento&lt;/em> &lt;code>mousedown&lt;/code>, a ser posteriormente definida como uma &lt;em>função&lt;/em> contendo as intruções a executar decorrentes desse evento, utilizando, se necessário, as propriedades &lt;code>ratoX&lt;/code> e &lt;code>ratoY&lt;/code>, associadas às coordenadas do &lt;em>rato&lt;/em> na &lt;em>tela&lt;/em>, já previamente obtidas e prontas a ser usadas
   * @type {function}
   */
  processaRatoDescido = function () { };

  /**
   * Propriedade correspondente ao &lt;em>evento&lt;/em> &lt;code>mouseup&lt;/code>, a ser posteriormente definida como uma &lt;em>função&lt;/em> contendo as intruções a executar decorrentes desse evento, utilizando, se necessário, as propriedades &lt;code>ratoX&lt;/code> e &lt;code>ratoY&lt;/code>, associadas às coordenadas do &lt;em>rato&lt;/em> na &lt;em>tela&lt;/em>, já previamente obtidas e prontas a ser usadas
   * @type {function}
   */
  processaRatoSubido = function () { };

  /**
   * Propriedade correspondente ao &lt;em>evento&lt;/em> &lt;code>mousemove&lt;/code>, a ser posteriormente definida como uma &lt;em>função&lt;/em> contendo as intruções a executar decorrentes desse evento, utilizando, se necessário, as propriedades &lt;code>ratoX&lt;/code> e &lt;code>ratoY&lt;/code>, associadas às coordenadas do &lt;em>rato&lt;/em> na &lt;em>tela&lt;/em>, já previamente obtidas e prontas a ser usadas
   * @type {function}
   */
  processaRatoMovido = function () { };

  /**
   * Propriedade correspondente ao &lt;em>evento&lt;/em> &lt;code>keydown&lt;/code>, a ser posteriormente definida como uma &lt;em>função&lt;/em> contendo as intruções a executar decorrentes desse evento, utilizando, se necessário, a propriedade &lt;code>codigoTecla&lt;/code>, associada à &lt;em>tecla&lt;/em> seleccionada, já previamente obtida e pronta a ser usada
   * @type {function}
   */
  processaTeclaDescida = function () { };

  /**
   * Propriedade correspondente ao &lt;em>evento&lt;/em> &lt;code>keyup&lt;/code>, a ser posteriormente definida como uma &lt;em>função&lt;/em> contendo as intruções a executar decorrentes desse evento, utilizando, se necessário, a propriedade &lt;code>codigoTecla&lt;/code>, associada à &lt;em>tecla&lt;/em> seleccionada, já previamente obtida e pronta a ser usada
   * @type {function}
   */
  processaTeclaSubida = function () { };

  /**
   * Contexto &lt;strong>2D&lt;/strong> da &lt;em>tela&lt;/em>, para acesso aos métodos nativamente disponibilizados pelo &lt;code>canvas&lt;/code>
   * @type {number}
   */
  get contexto() {
    return this.elemento.getContext("2d");
  }

  /**
   * Estilo &lt;code>CSS&lt;/code> do cursor do rato &lt;em>[definição]&lt;/em>
   * @type {string}
   */
  set cursor(cursor) {
    this.elemento.style.cursor = cursor;
  }

  /**
   * Estilo &lt;code>CSS&lt;/code> do cursor do rato &lt;em>[obtenção]&lt;/em>
   * @type {string}
   */
  get cursor() {
    return this.elemento.style.cursor;
  }

  /**
   * Largura da &lt;em>tela&lt;/em> (número de colunas)
   * @type {number}
   */
  get largura() {
    return this.elemento.width;
  }

  /**
   * Altura da &lt;em>tela&lt;/em> (número de linhas)
   * @type {number}
   */
  get altura() {
    return this.elemento.height;
  }

  /**
   * Largura final da &lt;em>tela&lt;/em>, considerando quaisquer alterações decorrentes da utilização de CSS para modificar a sua representação
   * @type {number}
   */
  get larguraFinal() {
    return this.elemento.offsetWidth;
  }

  /**
   * Altura final da &lt;em>tela&lt;/em>, considerando quaisquer alterações decorrentes da utilização de CSS para modificar a sua representação
   * @type {number}
   */
  get alturaFinal() {
    return this.elemento.offsetHeight;
  }

  /**
   * Abscissa do rato na &lt;em>tela&lt;/em> &lt;em>[definição]&lt;/em>
   * @type {number}
   */
  set ratoX(ratoX) {
    this.#ratoX = Math.floor(ratoX * this.escalaX);
  }

  /**
   * Ordenada do rato na &lt;em>tela&lt;/em> &lt;em>[definição]&lt;/em>
   * @type {number}
   */
  set ratoY(ratoY) {
    this.#ratoY = Math.floor(ratoY * this.escalaY);
  }

  /**
   * Abscissa do rato na &lt;em>tela&lt;/em> &lt;em>[obtenção]&lt;/em>
   * @type {number}
   */
  get ratoX() {
    return this.#ratoX;
  }

  /**
   * Ordenada do rato na &lt;em>tela&lt;/em> &lt;em>[obtenção]&lt;/em>
   * @type {number}
   */
  get ratoY() {
    return this.#ratoY;
  }

  /**
   * Escala resultante do rácio entre a resolução do canvas e a área ocupada pelo mesmo, relativa à largura (&lt;em>x&lt;/em>)
   * @type {number}
   */
  get escalaX() {
    return this.largura / this.larguraFinal;
  }

  /**
   * Escala resultante do rácio entre a resolução do canvas e a área ocupada pelo mesmo, relativa à altura (&lt;em>y&lt;/em>)
   * @type {number}
   */
  get escalaY() {
    return this.altura / this.alturaFinal;
  }
}

//

/**
 * @class
 * @classdesc A classe &lt;code>Media&lt;/code> é, na prática, uma classe &lt;em>abstracta&lt;/em>, servindo apenas de base para as subclasses de &lt;code>Media&lt;/code>. Para além disso, funcionará essencialmente como um envelope (&lt;em>wrapper&lt;/em>) para elementos de &lt;code>audio&lt;/code> e de &lt;code>video&lt;/code> em eventuais subclasses.
 * @property {HTMLElement} elemento O &lt;em>elemento&lt;/em> HTML a ser representado
 */
class Media {
  /**
   * Construtor da classe &lt;code>Media&lt;/code>. &lt;em>Este construtor não deve ser usado directamente. Se tal acontecer, é gerada uma excepção (&lt;code>TypeError&lt;/code>).&lt;/em>
   * @param {HTMLElement} elemento O &lt;em>elemento&lt;/em> HTML a ser representado
   */
  constructor(elemento) {
    this.elemento = elemento;
    if (this.constructor.name == "Media") {
      throw new TypeError("A classe abstracta 'Media' não pode ser instanciada directamente, devendo ser implementada através de subclasses (que poderão depois ser instanciadas).");
    }
  }

  /**
   * Fonte (origem) do elemento multimédia &lt;em>[definição]&lt;/em>
   * @type {string}
   */
  set fonte(ficheiro) {
    this.elemento.src = ficheiro;
  }

  /**
   * Fonte (origem) do elemento multimédia &lt;em>[obtenção]&lt;/em>
   * @type {string}
   */
  get fonte() {
    return this.elemento.src;
  }

  /**
   * Duração da reprodução do elemento multimédia &lt;em>[obtenção]&lt;/em>
   * @type {number}
   */
  get duracao() {
    return this.elemento.duration;
  }

  /**
   * Posição de reprodução do elemento multimédia &lt;em>[definição]&lt;/em> &amp;mdash; variando entre zero (&lt;code>0&lt;/code>) e um (&lt;code>1&lt;/code>)
   * @type {number}
   */
  set volume(volume) {
    this.elemento.volume = volume;
  }

  /**
    * Posição de reprodução do elemento multimédia &lt;em>[obtenção]&lt;/em> &amp;mdash; variando entre zero (&lt;code>0&lt;/code>) e um (&lt;code>1&lt;/code>)
    * @type {number}
    */
  get volume() {
    return this.elemento.volume;
  }

  /**
   * Posição de reprodução do elemento multimédia &lt;em>[definição]&lt;/em>
   * @type {number}
   */
  set posicao(tempo) {
    this.elemento.currentTime = tempo;
  }

  /**
   * Posição de reprodução do elemento multimédia &lt;em>[obtenção]&lt;/em>
   * @type {number}
   */
  get posicao() {
    return this.elemento.currentTime;
  }

  /**
   * Este método inicia ou retoma a reprodução do elemento multimédia
   * @param {boolean} inicio Indicação de que o elemento deve ser reproduzido do início; caso contrário, é reproduzido a partir do momento em que foi interrompida a sua reprodução anterior (ou do momento indicado pelo tempo de reprodução)
   */
  reproduz(inicio = false) {
    if (inicio) {
      this.elemento.currentTime = 0;
    }
    this.elemento.play();
  }

  /**
   * Este método pára a reprodução do elemento multimédia.
   */
  pausa() {
    this.elemento.pause();
  }

  /**
   * Este método pára a reprodução do elemento multimédia, voltando também ao seu início.
   */
  para() {
    this.pausa();
    this.elemento.currentTime = 0;
  }
}

/**
 * @class
 * @extends Media
 * @classdesc A classe &lt;code>Som&lt;/code> funciona essencialmente como um envelope (&lt;em>wrapper&lt;/em>) para elementos &lt;code>audio&lt;/code>, facilitando a sua criação e também uso de métodos mais comuns para, por exemplo, o controlo da sua reprodução.
 * @property {HTMLElement} elemento O &lt;em>elemento&lt;/em> HTML do tipo &lt;code>audio&lt;/code> a ser representado
 */
class Som extends Media {
  /**
   * Construtor da classe &lt;code>Som&lt;/code>
   * @param {HTMLElement} elemento  O &lt;em>elemento&lt;/em> HTML do tipo &lt;code>audio&lt;/code> a ser representado
   */
  constructor(elemento) {
    super(elemento);
  }
}

//

/**
 * @class
 * @extends Media
 * @classdesc A classe &lt;code>Filme&lt;/code> funciona essencialmente como um envelope (&lt;em>wrapper&lt;/em>) para elementos &lt;code>video&lt;/code>, facilitando a sua criação e também uso de métodos mais comuns para, por exemplo, o controlo da sua reprodução.
 * @property {HTMLElement} elemento O &lt;em>elemento&lt;/em> HTML do tipo &lt;code>video&lt;/code> a ser representado
 */
class Filme extends Media {
  /**
   * Construtor da classe &lt;code>Filme&lt;/code>
   * @param {HTMLElement} elemento O &lt;em>elemento&lt;/em> HTML do tipo &lt;code>video&lt;/code> a ser representado
   */
  constructor(elemento) {
    super(elemento);
  }

  /**
   * Largura do &lt;em>filme&lt;/em> (número de colunas)
   * @type {number}
   */
  get largura() {
    return this.elemento.videoWidth;
  }

  /**
   * Altura do &lt;em>filme&lt;/em> (número de linhas)
   * @type {number}
   */
  get altura() {
    return this.elemento.videoHeight;
  }

  /**
  * Largura final do &lt;em>filme&lt;/em>, considerando quaisquer alterações decorrentes da utilização de CSS para modificar a sua representação
  * @type {number}
  */
  get larguraFinal() {
    return this.elemento.offsetWidth;
  }

  /**
   * Altura final do &lt;em>filme&lt;/em>, considerando quaisquer alterações decorrentes da utilização de CSS para modificar a sua representação
   * @type {number}
   */
  get alturaFinal() {
    return this.elemento.offsetHeight;
  }
}

//

/**
 * @typedef {Object} PontoPolar
 * @property {number} distancia Distância radial do ponto
 * @property {number} angulo Ângulo polar do ponto
 */

/**
 * @typedef {Object} PontoCartesiano
 * @property {number} x Abscissa do ponto cartesiano
 * @property {number} y Ordenada do ponto cartesiano
 */

//

/**
 * @class
 * @classdesc A classe &lt;code>Utilitarios&lt;/code> serve apenas como agregador de alguns métodos e propriedades estáticos para uso noutras classes ou blocos de código.
 * @hideconstructor
 */
class Utilitarios {

  /** 
   * Constante que representa a ausência de &lt;em>reposicionamento&lt;/em> &amp;mdash; usada no método &lt;code>colide()&lt;/code>, com &lt;code>reposicionamento = true&lt;/code>, da classe &lt;code>Grafico&lt;/code> e respectivas subcasses
   *  @constant
   *  @type {number}
   *  @default
   */
  static FALSO = 0;

  /** 
   * Constante que representa um &lt;em>reposicionamento&lt;/em> em &lt;em>cima&lt;/em> &amp;mdash; usada no método &lt;code>colide()&lt;/code>, com &lt;code>reposicionamento = true&lt;/code>, da classe &lt;code>Grafico&lt;/code> e respectivas subcasses
   *  @constant
   *  @type {number}
   *  @default
   */
  static CIMA = 1;

  /** 
   * Constante que representa um &lt;em>reposicionamento&lt;/em> em &lt;em>baixo&lt;/em> &amp;mdash; usada no método &lt;code>colide()&lt;/code>, com &lt;code>reposicionamento = true&lt;/code>, da classe &lt;code>Grafico&lt;/code> e respectivas subcasses
   *  @constant
   *  @type {number}
   *  @default
   */
  static BAIXO = 2;

  /** 
   * Constante que representa um &lt;em>reposicionamento&lt;/em> à &lt;em>esquerda&lt;/em> &amp;mdash; usada no método &lt;code>colide()&lt;/code>, com &lt;code>reposicionamento = true&lt;/code>, da classe &lt;code>Grafico&lt;/code> e respectivas subcasses
   *  @constant
   *  @type {number}
   *  @default
   */
  static ESQUERDA = 3;

  /** 
   * Constante que representa um &lt;em>reposicionamento&lt;/em> à &lt;em>direita&lt;/em> &amp;mdash; usada no método &lt;code>colide()&lt;/code>, com &lt;code>reposicionamento = true&lt;/code>, da classe &lt;code>Grafico&lt;/code> e respectivas subcasses
   *  @constant
   *  @type {number}
   *  @default
   */
  static DIREITA = 4;

  /**
   * Este método cálcula as coordenadas polares de um dado ponto cartesiano, devolvendo o &lt;em>ângulo polar&lt;/em> e a &lt;em>distância radial&lt;/em>.
   * @param {number} x Abscissa do ponto cartesiano
   * @param {number} y Ordenada do ponto cartesiano
   * @returns {PontoPolar} Coordenadas polares (&lt;em>distância&lt;/em>, &lt;em>ângulo&lt;/em>) do ponto
   */
  static calculaCoordenadasPolares(x, y) {
    var distancia = Math.hypot(x, y);
    var angulo = null;
    if (x > 0) {
      angulo = Math.atan(y / x) * 180 / Math.PI;
    }
    else if (x &lt; 0 &amp;&amp; y >= 0) {
      angulo = (Math.atan(y / x) + Math.PI) * 180 / Math.PI;
    }
    else if (x &lt; 0 &amp;&amp; y &lt; 0) {
      angulo = (Math.atan(y / x) - Math.PI) * 180 / Math.PI;
    }
    else if (x == 0 &amp;&amp; y > 0) {
      angulo = (Math.PI / 2) * 180 / Math.PI;
    }
    else if (x &lt; 0 &amp;&amp; y &lt; 0) {
      angulo = -(Math.PI / 2) * 180 / Math.PI;
    }
    else if (x == 0 &amp;&amp; y == 0) {
      angulo = null;
    }
    return { distancia: distancia, angulo: angulo };
  }

  /**
   * Este método cálcula as coordenadas cartesianas de um dado ponto polar, devolvendo o &lt;em>x&lt;/em> e o &lt;em>y&lt;/em>.
   * @param {number} distancia Distância radial do ponto
   * @param {number} angulo Ângulo polar do ponto
   * @returns {PontoCartesiano} Coordenadas cartesianas (&lt;em>x&lt;/em>, &lt;em>y&lt;/em>) do ponto
   */
  static calculaCoordenadasCartesianas(distancia, angulo) {
    var x = distancia * Math.cos(angulo * Math.PI / 180);
    var y = distancia * Math.sin(angulo * Math.PI / 180);
    return { x: x, y: y };
  }

  /**
   * Este método desenha um &lt;em>gráfico&lt;/em> ou percorre um &lt;em>array&lt;/em> de &lt;em>gráficos&lt;/em> (instâncias ou objectos de subclasses da classe &lt;code>Grafico&lt;/code>) e desenha-os no &lt;code>canvas&lt;/code> especificado. O método funciona de forma recursiva, pelo que o &lt;em>array&lt;/em> pode conter, ele próprio, também &lt;em>arrays&lt;/em> em qualquer das suas posições.
   * @param {Grafico} graficos Um &lt;em>array&lt;/em> de &lt;em>gráficos&lt;/em> ou mesmo apenas um único &lt;em>gráfico&lt;/em>
   * @param {Tela} tela O &lt;code>canvas&lt;/code> onde vão ser desenhados os &lt;em>gráficos&lt;/em>
   */
  static desenhaGraficos(graficos, tela) {
    for (var i = 0; i &lt; graficos.length; i++) {
      if (Array.isArray(graficos[i])) {
        desenhaGraficos(graficos[i], tela);
      } else {
        graficos[i].desenha(tela);
      }
    }
  }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Circulo.html">Circulo</a></li><li><a href="Filme.html">Filme</a></li><li><a href="Grafico.html">Grafico</a></li><li><a href="Imagem.html">Imagem</a></li><li><a href="ImagemAnimada.html">ImagemAnimada</a></li><li><a href="ImagemFilme.html">ImagemFilme</a></li><li><a href="Media.html">Media</a></li><li><a href="Poligono.html">Poligono</a></li><li><a href="Rectangulo.html">Rectangulo</a></li><li><a href="Som.html">Som</a></li><li><a href="Tela.html">Tela</a></li><li><a href="Texto.html">Texto</a></li><li><a href="Utilitarios.html">Utilitarios</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Mon Apr 17 2023 22:33:08 GMT+0100 (Western European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
